{"meta":{"title":"个人博客","subtitle":"","description":"个人学习的一些记录。","author":"f19t","url":"https://f19t.github.io.git","root":"/"},"pages":[{"title":"分类","date":"2023-02-12T08:31:42.000Z","updated":"2023-02-13T09:31:55.647Z","comments":true,"path":"categories/index.html","permalink":"https://f19t.github.io.git/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-02-12T08:25:34.000Z","updated":"2023-02-13T09:31:47.571Z","comments":true,"path":"tags/index.html","permalink":"https://f19t.github.io.git/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"NYOJ58-广度优先搜索算法","slug":"NYOJ58-广度优先搜索算法","date":"2023-02-17T12:28:31.000Z","updated":"2023-02-17T12:31:28.493Z","comments":true,"path":"2023/02/17/NYOJ58-广度优先搜索算法/","link":"","permalink":"https://f19t.github.io.git/2023/02/17/NYOJ58-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/","excerpt":"NYOJ-58-广度优先搜索算法最近三天学习了深度优先算法，并做了一道oj题，遇到了一些问题，并解决了一些问题，这里记录一下。","text":"NYOJ-58-广度优先搜索算法最近三天学习了深度优先算法，并做了一道oj题，遇到了一些问题，并解决了一些问题，这里记录一下。 题目描述：描述这有一个迷宫，有0~8行和0~8列： 1,1,1,1,1,1,1,1,1 1,0,0,1,0,0,1,0,1 1,0,0,1,1,0,0,0,1 1,0,1,0,1,1,0,1,1 1,0,0,0,0,1,0,0,1 1,1,0,1,0,1,0,0,1 1,1,0,1,0,1,0,0,1 1,1,0,1,0,0,0,0,1 1,1,1,1,1,1,1,1,1 0表示道路，1表示墙。现在输入一个道路的坐标作为起点，再如输入一个道路的坐标作为终点，问最少走几步才能从起点到达终点？（注：一步是指从一坐标点走到其上下左右相邻坐标点，如：从（3，1）到（4,1）。） 输入描述第一行输入一个整数n（0&lt;n&lt;&#x3D;100），表示有n组测试数据;随后n行,每行有四个整数a,b,c,d（0&lt;&#x3D;a,b,c,d&lt;&#x3D;8）分别表示起点的行、列，终点的行、列。 输出描述 输出最少走几步。 解题源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394import java.util.*;public class OJ58 &#123; static int[][] walked =new int[9][9]; //记录那些路径走过 static Queue&lt;location&gt; queue = new LinkedList&lt;location&gt;();//创建队列，将所有的位置都走一遍 static int[][] map=&#123;&#123;1,1,1,1,1,1,1,1,1&#125;, &#123;1,0,0,1,0,0,1,0,1&#125;, &#123;1,0,0,1,1,0,0,0,1&#125;, &#123;1,0,1,0,1,1,0,1,1&#125;, &#123;1,0,0,0,0,1,0,0,1&#125;, &#123;1,1,0,1,0,1,0,0,1&#125;, &#123;1,1,0,1,0,1,0,0,1&#125;, &#123;1,1,0,1,0,0,0,0,1&#125;, &#123;1,1,1,1,1,1,1,1,1&#125;&#125;; public static void main(String[] args) &#123; Scanner in =new Scanner(System.in); int n = in.nextInt(); for (int i = 0; i &lt; n; i++) &#123; int a = in.nextInt(); int b = in.nextInt(); int c = in.nextInt(); int d = in.nextInt(); if (a == c &amp;&amp; b == d) &#123; System.out.println(0); continue; &#125; move(a, b,0); while (queue.size() != 0) &#123; location laca = queue.poll();// System.out.print(&quot;走过(&quot;);// System.out.print(laca.x);// System.out.print(&quot;,&quot;);// System.out.print(laca.y);// System.out.print(&quot;)位置&quot;);// System.out.print(&quot;，步数&quot;);// System.out.println(laca.step); if (laca.x == c &amp;&amp; laca.y == d) &#123; System.out.println(laca.step); queue.clear(); for (int w = 0; w &lt; 9; w++) &#123; Arrays.fill(walked[w], 0);//二维数组全部赋值为0 &#125; break; &#125; else &#123; move(laca.x,laca.y, laca.step); &#125; &#125; &#125; &#125; private static void move(int x, int y, int steps) &#123; //每个点上下左右移动 ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(1); list.add(-1); for (int i : list) &#123; if (x + i &gt; -1 &amp;&amp; x + i &lt;= 8 &amp;&amp; walked[x + i][y] == 0 &amp;&amp; map[x + i][y] == 0) &#123; walked[x + i][y] = 1; location laca = new location(); laca.x = x + i; laca.y = y; laca.step =steps+1; queue.offer(laca); &#125; &#125; for (int i : list) &#123; if (y + i &gt; -1 &amp;&amp; y + i &lt;= 8 &amp;&amp; walked[x][y + i] == 0 &amp;&amp; map[x][y + i] == 0) &#123; walked[x][y + i] = 1; location laca = new location(); laca.x = x; laca.y = y+i; laca.step = steps+1; queue.offer(laca); &#125; &#125; &#125;&#125;class location &#123; int x; int y; int step;&#125; 遇到的问题java结构体java没有结构体，Queue E是泛型 可以自己构建类去充当元素，使用object &#x3D;null去释放赋值对象。 123456789//Interface Queue&lt;E&gt;class location &#123; int x; int y; int step;&#125;location laca = new location();queue.offer(laca); 多维数组赋值为0java.util.Arrays.fill()方法处理的是一维数组，处理二维数组使用： 123for (int w = 0; w &lt; 9; w++) &#123; Arrays.fill(walked[w], 0);//二维数组全部赋值为0&#125; 心得广度优先搜索可以解决最短路径问题，像火一样蔓延，一层层去查找。","categories":[{"name":"OJ","slug":"OJ","permalink":"https://f19t.github.io.git/categories/OJ/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://f19t.github.io.git/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"NYOJ-32-深度优先搜索算法","slug":"NYOJ32-深度优先搜索算法","date":"2023-02-15T03:24:28.000Z","updated":"2023-02-15T07:39:57.412Z","comments":true,"path":"2023/02/15/NYOJ32-深度优先搜索算法/","link":"","permalink":"https://f19t.github.io.git/2023/02/15/NYOJ32-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/","excerpt":"NYOJ-32-深度优先搜索算法最近两天学习了深度优先算法，并做了一道oj题，这里记录一下。","text":"NYOJ-32-深度优先搜索算法最近两天学习了深度优先算法，并做了一道oj题，这里记录一下。 题目描述：描述找出从自然数1、2、… 、n（0&lt;n&lt;10）中任取r(0&lt;r&lt;&#x3D;n)个数的所有组合。 输入描述输入n、r。 输出描述按特定顺序输出所有组合。特定顺序：每一个组合中的值从大到小排列，组合之间按逆字典序排列。 123456789101112输入 5 3输出：543542541532531521432431421321 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.Scanner;public class NYOJ32 &#123; //组合数，深度优先搜索 static Scanner in =new Scanner(System.in); static int n = in.nextInt(); //读取基础数据 static int r = in.nextInt(); //读取长度 static int[] book = new int[n+1];//标记数据是否被使用 static int[] out = new int[r+1]; //设置输出长度 public static void main(String[] args) &#123; dfs(1); &#125; public static void dfs(int step) &#123; int i = 0; if (step &gt; r) &#123; for (i=1;i&lt;=r-1;i++)&#123; //判断高位大于低位 if (out[i]&lt;out[i+1])&#123; return; &#125; &#125; for (i = 1; i &lt;=r; i++) &#123; System.out.print(out[i]); &#125; System.out.println(&quot;&quot;); return; &#125; for (i = n; i &gt; 0; i--) &#123; //深度优先算法 if (book[i] == 0) &#123; out[step]=i; book[i]=1; dfs(step+1); book[i]=0; &#125; &#125; return; &#125;&#125; 学到了，理解深度优先搜索的关键在于解决 “当下该如何做” 。至于 “下一步如何做” 则与 “当下该如何做” 是一样的。","categories":[{"name":"OJ","slug":"OJ","permalink":"https://f19t.github.io.git/categories/OJ/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://f19t.github.io.git/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"NYOJ-2-栈的运用","slug":"NYOJ-2","date":"2023-02-13T11:16:31.000Z","updated":"2023-02-15T07:36:57.201Z","comments":true,"path":"2023/02/13/NYOJ-2/","link":"","permalink":"https://f19t.github.io.git/2023/02/13/NYOJ-2/","excerpt":"NYOJ-2-栈的运用今天刚学java集合，学到了栈，就拿这道题练练手吧。 题目描述12输入描述第一行输入一个数N（0&lt;N&lt;=100）,表示有N组测试数据。后面的N行输入多组输入数据，每组输入数据都是一个字符串S(S的长度小于10000，且S不是空串），测试数据组数少于5组。数据保证S中只含有&quot;[&quot;, “]”, “(”, “)” 四种字符 1每组输入数据的输出占一行，如果该字符串中所含的括号是配对的，则输出Yes,如果不配对则输出No","text":"NYOJ-2-栈的运用今天刚学java集合，学到了栈，就拿这道题练练手吧。 题目描述12输入描述第一行输入一个数N（0&lt;N&lt;=100）,表示有N组测试数据。后面的N行输入多组输入数据，每组输入数据都是一个字符串S(S的长度小于10000，且S不是空串），测试数据组数少于5组。数据保证S中只含有&quot;[&quot;, “]”, “(”, “)” 四种字符 1每组输入数据的输出占一行，如果该字符串中所含的括号是配对的，则输出Yes,如果不配对则输出No 解题思路最近刚学了Deque，可以使用栈解决这个问题。思路：获取到”)”、”]”，就比对，不是就压栈，最后判断是否为空。后续有更好思路再补代码。 1234567891011121314151617181920212223242526272829303132333435363738import java.util.Deque;import java.util.LinkedList;import java.util.Scanner;public class OJ2 &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int num = in.nextInt(); String arr[] = new String[num]; for (int i = 0; i&lt;num;i++)&#123;arr[i]=in.next();&#125; for (int i = 0; i&lt;num;i++)&#123; String s = judge(arr[i]); System.out.println(s); &#125; &#125; public static String judge(String s)&#123; Deque&lt;String&gt; deque = new LinkedList&lt;&gt;(); for (int i =0;i&lt;s.length();i++)&#123; deque.offerLast(s.substring(i,i+1)); if (deque.peekLast().equals(&quot;)&quot;))&#123; if (deque.size()==1)&#123;return &quot;No&quot;;&#125; deque.pollLast(); if (deque.peekLast().equals(&quot;(&quot;))&#123;deque.removeLast();&#125; else &#123;return &quot;No&quot;;&#125; &#125; else if(deque.peekLast().equals(&quot;]&quot;))&#123; if (deque.size()==1)&#123;return &quot;No&quot;;&#125; deque.pollLast(); if (deque.peekLast().equals(&quot;[&quot;))&#123;deque.removeLast();&#125; else &#123;return &quot;No&quot;;&#125; &#125; &#125; if (deque.size()==0)&#123;return &quot;Yes&quot;;&#125;else &#123;return &quot;No&quot;;&#125; &#125;&#125; 学到了比较值需要使用 .equals() 。","categories":[{"name":"OJ","slug":"OJ","permalink":"https://f19t.github.io.git/categories/OJ/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://f19t.github.io.git/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Java集合","slug":"Java集合","date":"2023-02-13T07:38:34.000Z","updated":"2023-02-13T11:26:52.908Z","comments":true,"path":"2023/02/13/Java集合/","link":"","permalink":"https://f19t.github.io.git/2023/02/13/Java%E9%9B%86%E5%90%88/","excerpt":"Java集合本文介绍Java集合的数据结构，与简单测试。为后续学习算法打基础。","text":"Java集合本文介绍Java集合的数据结构，与简单测试。为后续学习算法打基础。 List123456789101112131415import java.util.ArrayList;import java.util.List;public class Test &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;apple&quot;); // size=1 list.add(&quot;pear&quot;); // size=2 list.add(&quot;apple&quot;); // 允许重复添加元素，size=3 System.out.println(list.size()); list.remove(1);//删除pear System.out.println(list.size()); System.out.println(list.get(1)); &#125;&#125; 12332apple List是一种顺序列表接口常用方法： 在末尾添加一个元素：boolean add(E e) 在指定索引添加一个元素：boolean add(int index, E e) 删除指定索引的元素：E remove(int index) 删除某个元素：boolean remove(Object e) 获取指定索引的元素：E get(int index) 获取链表大小（包含元素的个数）：int size() Map1234567891011121314151617import java.util.HashMap;import java.util.Map;public class Test &#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;s&quot;,&quot;bbbbb&quot;); map.put(&quot;a&quot;,&quot;aaaaa&quot;); System.out.println(map.get(&quot;s&quot;));//获取数据 for (String key : map.keySet())&#123; //遍历map System.out.println(map.get(key)); &#125; &#125;&#125; 123bbbbbaaaaabbbbb PropertiesJava默认配置文件以.properties为扩展名，每行以key&#x3D;value表示。java内置Properties读取配置文件非常简单。 典型配置文件： 123# setting.propertieslast_open_file=1.txtauto_save_interval=60 12345678910111213141516171819import java.io.FileNotFoundException;import java.util.Properties;public class Test &#123; public static void main(String[] args) throws FileNotFoundException,Exception&#123; String f = &quot;配置文件&quot;; Properties props = new Properties(); props.load(new java.io.FileInputStream(f)); String filepath = props.getProperty(&quot;last_open_file&quot;); String interval = props.getProperty(&quot;auto_save_interval&quot;, &quot;120&quot;);//如果没有值，赋予默认值 System.out.println(filepath); System.out.println(interval); &#125;&#125; 121.txt60 Set只需要存储不重复的key，并不需要存储映射的value，那么就可以使用Set。 Queue队列（Queue）是一种经常使用的集合。Queue实际上是实现了一个先进先出（FIFO：First In First Out）的有序表。它和List的区别在于，List可以在任意位置添加和删除元素，而Queue只有两个操作： 把元素添加到队列末尾； 从队列头部取出元素。 队列接口Queue定义了以下几个方法： int size()：获取队列长度； boolean add(E)&#x2F;boolean offer(E)：添加元素到队尾； E remove()&#x2F;E poll()：获取队首元素并从队列中删除； E element()&#x2F;E peek()：获取队首元素但并不从队列中删除。 123456789101112131415161718192021222324import java.io.FileNotFoundException;import java.util.*;public class Test &#123; public static void main(String[] args) throws FileNotFoundException,Exception&#123; Queue&lt;String&gt; q = new LinkedList&lt;&gt;(); q.offer(&quot;aaaaaaa&quot;); q.offer(&quot;bbbbbbb&quot;); q.offer(&quot;ccccccc&quot;); System.out.println(q.peek());//获取首位数据，不删除 System.out.println(q.peek()); System.out.println(q.peek()); System.out.println(&quot;-------------&quot;); System.out.println(q.poll());//获取首位数据，并删除 System.out.println(q.poll()); System.out.println(q.poll()); &#125;&#125; 1234567aaaaaaaaaaaaaaaaaaaaa-------------aaaaaaabbbbbbbccccccc Deque两头都出，这种队列叫双端队列（Double Ended Queue），学名Deque。Java集合提供了接口Deque来实现一个双端队列，它的功能是： 既可以添加到队尾，也可以添加到队首； 既可以从队首获取，又可以从队尾获取。 用处：Deque当Stack使用。 123456789101112131415161718192021222324import java.io.FileNotFoundException;import java.util.*;public class Test &#123; public static void main(String[] args) throws FileNotFoundException,Exception&#123; Deque&lt;String&gt; q = new LinkedList&lt;&gt;(); q.offerLast(&quot;aaaaaaa&quot;); q.offerLast(&quot;bbbbbbb&quot;); q.offerLast(&quot;ccccccc&quot;); System.out.println(q.peekLast());//获取末位数据，不删除 System.out.println(q.peekLast()); System.out.println(q.peekLast()); System.out.println(&quot;-------------&quot;); System.out.println(q.pollLast());//获取末位数据，并删除 System.out.println(q.pollLast()); System.out.println(q.pollLast()); &#125;&#125; 1234567ccccccccccccccccccccc-------------cccccccbbbbbbbaaaaaaa","categories":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"https://f19t.github.io.git/categories/JAVA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://f19t.github.io.git/tags/%E7%AE%97%E6%B3%95/"}]}],"categories":[{"name":"OJ","slug":"OJ","permalink":"https://f19t.github.io.git/categories/OJ/"},{"name":"JAVA基础","slug":"JAVA基础","permalink":"https://f19t.github.io.git/categories/JAVA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://f19t.github.io.git/tags/%E7%AE%97%E6%B3%95/"}]}