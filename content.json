{"meta":{"title":"个人博客","subtitle":"","description":"个人学习的一些记录。","author":"f19t","url":"https://f19t.github.io.git","root":"/"},"pages":[{"title":"分类","date":"2023-02-12T08:31:42.000Z","updated":"2023-02-13T09:31:55.647Z","comments":true,"path":"categories/index.html","permalink":"https://f19t.github.io.git/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-02-12T08:25:34.000Z","updated":"2023-02-13T09:31:47.571Z","comments":true,"path":"tags/index.html","permalink":"https://f19t.github.io.git/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java反射","slug":"Java反射","date":"2023-02-19T11:58:26.000Z","updated":"2023-02-19T12:03:36.571Z","comments":true,"path":"2023/02/19/Java反射/","link":"","permalink":"https://f19t.github.io.git/2023/02/19/Java%E5%8F%8D%E5%B0%84/","excerpt":"java反射之前学过反射，半知半解，今天重新学习一下Java反射机制，以及能做的事情。","text":"java反射之前学过反射，半知半解，今天重新学习一下Java反射机制，以及能做的事情。 下面是反射获取类Test的的源码： 1234567891011121314151617181920212223242526272829import java.io.IOException;import java.lang.Runtime;public class Test &#123; public static final int h = 5;//字段1，直接赋值 public String s = &quot;test&quot;;//字段2 public static final boolean b =new Boolean(false);//字段3，间接赋值 public Test() &#123; //构造函数1 System.out.println(&quot;无参构造函数&quot;); &#125; public Test(int m, double n) throws IOException &#123;//有参构造函数2 System.out.println(&quot;有参构造函数&quot;); System.out.println(&quot;获取到int=&quot;+m); System.out.println(&quot;获取到double=&quot;+n); Runtime.getRuntime().exec(&quot;open /System/Applications/Calculator.app&quot;); &#125; public String hello(String s) &#123; //方法1 System.out.println(&quot;调用hello&quot;); return &quot;Hello World~&quot;; &#125; public int hello2(int x,double y) throws IOException &#123; //方法2 System.out.println(&quot;获取到int=&quot;+x); System.out.println(&quot;获取到double=&quot;+y); Runtime.getRuntime().exec(&quot;open /System/Applications/Calculator.app&quot;); return 3; &#125;&#125; 反射创建对象实例12345678910111213141516171819202122232425import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;/** * author: f19t * Date: 2023/2/18 21:44 */public class Test_Reflect_getConstructor &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123; Class c = Class.forName(&quot;Test&quot;); Constructor ct1 = c.getConstructor();//不会初始化，无参构造 Test obj = (Test)ct1.newInstance();//初始化执行 obj.hello(&quot;test&quot;); Class partypes[] = new Class[2]; partypes[0] = Integer.TYPE; partypes[1] = Double.TYPE; Constructor ct2 = c.getConstructor(partypes);//不会初始化，有参构造 Object arglist[] = new Object[2]; arglist[0] = new Integer(37); arglist[1] = new Double(47.0); Object obj2 = ct2.newInstance(arglist);//有参生成对象 &#125;&#125; 反射获取类方法123456789101112131415161718192021222324import java.lang.reflect.Method;/** * author: f19t * Date: 2023/2/18 19:12 */public class Test_Reflect_methods &#123;public static void main(String[]args) throws ClassNotFoundException &#123; Class c = Class.forName(&quot;java.lang.Runtime&quot;);//获取类 Method methods[] = c.getDeclaredMethods();//获取所有方法 for (int i = 0; i &lt; methods.length; i++) &#123; Method m = methods[i]; Class pvec[] =m.getParameterTypes();// System.out.println(&quot;类名=&quot; +m.getDeclaringClass());//获取类名 System.out.println(&quot;方法=&quot;+m.getName());//获取方法名 for (int q = 0; q &lt; pvec.length; q++) &#123; System.out.println(&quot;参数类型&quot;+pvec[q].getName()); //获取方法参数 &#125; System.out.println(&quot;返回类型=&quot;+m.getReturnType());//获取返回类型 System.out.println(&quot;-----------------------------&quot;); &#125;&#125;&#125; 获取字段123456789101112131415161718192021222324import java.lang.reflect.Field;import java.lang.reflect.Modifier;/** * author: f19t * Date: 2023/2/18 20:43 */public class Test_Reflect_field &#123; public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123; Class c = Class.forName(&quot;Test&quot;); Field fieldlist[] = c.getDeclaredFields(); for (int i = 0; i &lt; fieldlist.length; i++) &#123; fieldlist[i].setAccessible(true); System.out.println(&quot;字段名=&quot;+fieldlist[i].getName()); System.out.println(&quot;字段值=&quot;+fieldlist[i].get(c.newInstance()));//get方法需要传入实例对象 System.out.println(&quot;字段类型=&quot;+fieldlist[i].getType()); int mod = fieldlist[i].getModifiers(); System.out.println(&quot;声明类型=&quot;+ Modifier.toString(mod)); System.out.println(&quot;----------------------------&quot;); &#125; &#125;&#125; 运行结果 12345678910111213141516171819字段名=h无参构造函数字段值=5字段类型=int声明类型=public static final----------------------------字段名=s无参构造函数字段值=test字段类型=class java.lang.String声明类型=public----------------------------字段名=b无参构造函数字段值=false字段类型=boolean声明类型=public static final---------------------------- 修改字段反射修改注意如果是static final修饰的，需要先去掉final，再次进行修改，还需要注意，static final修饰的直接赋值还是间接赋值，直接赋值只能通过反射获取修改后的数据（编译优化导致）。间接赋值的可以直接获取修改后的数据。 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.io.IOException;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Modifier;/** * author: f19t * Date: 2023/2/18 22:03 */public class Test_Reflect_Set_field &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchFieldException, IOException &#123; Class c = Class.forName(&quot;Test&quot;); Field field[] = c.getDeclaredFields(); Test obj = (Test) c.newInstance(); for (int i = 0; i &lt; field.length; i++) &#123; System.out.println(&quot;修改前的值&quot;+field[i].getName()+&quot;=&quot;+field[i].get(obj)+&quot; 类型为 &quot;+Modifier.toString(field[i].getModifiers())); &#125; System.out.println(&quot;------------------&quot;); field[0].setAccessible(true); Field modifiers = field[0].getClass().getDeclaredField(&quot;modifiers&quot;); modifiers.setAccessible(true); modifiers.setInt(field[0], field[0].getModifiers() &amp; ~Modifier.FINAL); field[0].set(obj, 10); System.out.println(&quot;反射修改后直接获取&quot;+field[0].getName()+&quot;=&quot;+obj.h); System.out.println(&quot;反射修改后反射获取&quot;+field[0].getName()+&quot;=&quot;+field[0].get(obj)); System.out.println(&quot;--------------------&quot;); field[1].setAccessible(true); modifiers.setInt(field[1], field[1].getModifiers() &amp; ~Modifier.FINAL); field[1].set(obj, &quot;hack&quot;); System.out.println(&quot;反射修改后直接获取&quot;+field[1].getName()+&quot;=&quot;+obj.s); System.out.println(&quot;反射修改后反射获取&quot;+field[1].getName()+&quot;=&quot;+field[1].get(obj)); System.out.println(&quot;--------------------&quot;); field[2].setAccessible(true); modifiers.setInt(field[2], field[2].getModifiers() &amp; ~Modifier.FINAL); field[2].set(obj, true); System.out.println(&quot;反射修改后直接获取&quot;+field[2].getName()+&quot;=&quot;+obj.b); System.out.println(&quot;反射修改后反射获取&quot;+field[2].getName()+&quot;=&quot;+field[2].get(obj)); &#125;&#125; 运行结果： 12345678910111213无参构造函数修改前的值h=5 类型为 public static final修改前的值s=test 类型为 public修改前的值b=false 类型为 public static final------------------反射修改后直接获取h=5反射修改后反射获取h=10--------------------反射修改后直接获取s=hack反射修改后反射获取s=hack--------------------反射修改后直接获取b=true反射修改后反射获取b=true 调用方法常规类调用方法常规类调用方法流程为获取类、创建实例、执行方法 1234567891011121314151617181920212223import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;/** * author: f19t * Date: 2023/2/18 21:22 */public class Test_Reflect_Get_methods &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123; Class c = Class.forName(&quot;Test&quot;); Class partypes[] = new Class[2]; partypes[0] = Integer.TYPE; partypes[1] = Double.TYPE; Method meth = c.getMethod(&quot;hello2&quot;, partypes); Test test = new Test(); Object arglist[] = new Object[2]; arglist[0] = new Integer(3); arglist[1] = new Double(3.1); Object ref = meth.invoke(test, arglist); System.out.println(ref); &#125;&#125; 单例类调用方法单例模式的特点 单例类只能有一个实例。 单例类必须自己创建自己的唯一实例。 单例类必须给所有其他对象提供这一实例。 单例模式保证了全局对象的唯一性，比如系统启动读取配置文件就需要单例保证配置的一致性。 java.lang.Runtime就是一个单例模式 1234567891011121314151617public class Runtime &#123; private static Runtime currentRuntime = new Runtime(); /** * Returns the runtime object associated with the current Java application. * Most of the methods of class &lt;code&gt;Runtime&lt;/code&gt; are instance * methods and must be invoked with respect to the current runtime object. * * @return the &lt;code&gt;Runtime&lt;/code&gt; object associated with the current * Java application. */ public static Runtime getRuntime() &#123; return currentRuntime; &#125; /** Don&#x27;t let anyone else instantiate this class */ private Runtime() &#123;&#125; Runtime的调用这里直接放代码了，有个小点没搞懂，后续搞懂了之后再回来补充。 123456789101112131415161718import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;/** * author: f19t * Date: 2023/2/18 21:22 */public class Test_Reflect_Get_methods &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException &#123; Class c = Class.forName(&quot;java.lang.Runtime&quot;); Method method = c.getDeclaredMethod(&quot;exec&quot;, String.class); Method method1 = c.getDeclaredMethod(&quot;getRuntime&quot;); Object obj = method1.invoke(c);//不明白这个地方为什么放类可以，难到单例模式类，本身就是对象吗？ method.invoke(obj, &quot;open /System/Applications/Calculator.app&quot;); &#125;&#125;","categories":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"https://f19t.github.io.git/categories/JAVA%E5%9F%BA%E7%A1%80/"},{"name":"JAVA安全","slug":"JAVA基础/JAVA安全","permalink":"https://f19t.github.io.git/categories/JAVA%E5%9F%BA%E7%A1%80/JAVA%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JAVASEC","slug":"JAVASEC","permalink":"https://f19t.github.io.git/tags/JAVASEC/"}]},{"title":"NYOJ58-广度优先搜索算法","slug":"NYOJ58-广度优先搜索算法","date":"2023-02-17T12:28:31.000Z","updated":"2023-02-17T12:31:28.493Z","comments":true,"path":"2023/02/17/NYOJ58-广度优先搜索算法/","link":"","permalink":"https://f19t.github.io.git/2023/02/17/NYOJ58-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/","excerpt":"NYOJ-58-广度优先搜索算法最近三天学习了深度优先算法，并做了一道oj题，遇到了一些问题，并解决了一些问题，这里记录一下。","text":"NYOJ-58-广度优先搜索算法最近三天学习了深度优先算法，并做了一道oj题，遇到了一些问题，并解决了一些问题，这里记录一下。 题目描述：描述这有一个迷宫，有0~8行和0~8列： 1,1,1,1,1,1,1,1,1 1,0,0,1,0,0,1,0,1 1,0,0,1,1,0,0,0,1 1,0,1,0,1,1,0,1,1 1,0,0,0,0,1,0,0,1 1,1,0,1,0,1,0,0,1 1,1,0,1,0,1,0,0,1 1,1,0,1,0,0,0,0,1 1,1,1,1,1,1,1,1,1 0表示道路，1表示墙。现在输入一个道路的坐标作为起点，再如输入一个道路的坐标作为终点，问最少走几步才能从起点到达终点？（注：一步是指从一坐标点走到其上下左右相邻坐标点，如：从（3，1）到（4,1）。） 输入描述第一行输入一个整数n（0&lt;n&lt;&#x3D;100），表示有n组测试数据;随后n行,每行有四个整数a,b,c,d（0&lt;&#x3D;a,b,c,d&lt;&#x3D;8）分别表示起点的行、列，终点的行、列。 输出描述 输出最少走几步。 解题源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394import java.util.*;public class OJ58 &#123; static int[][] walked =new int[9][9]; //记录那些路径走过 static Queue&lt;location&gt; queue = new LinkedList&lt;location&gt;();//创建队列，将所有的位置都走一遍 static int[][] map=&#123;&#123;1,1,1,1,1,1,1,1,1&#125;, &#123;1,0,0,1,0,0,1,0,1&#125;, &#123;1,0,0,1,1,0,0,0,1&#125;, &#123;1,0,1,0,1,1,0,1,1&#125;, &#123;1,0,0,0,0,1,0,0,1&#125;, &#123;1,1,0,1,0,1,0,0,1&#125;, &#123;1,1,0,1,0,1,0,0,1&#125;, &#123;1,1,0,1,0,0,0,0,1&#125;, &#123;1,1,1,1,1,1,1,1,1&#125;&#125;; public static void main(String[] args) &#123; Scanner in =new Scanner(System.in); int n = in.nextInt(); for (int i = 0; i &lt; n; i++) &#123; int a = in.nextInt(); int b = in.nextInt(); int c = in.nextInt(); int d = in.nextInt(); if (a == c &amp;&amp; b == d) &#123; System.out.println(0); continue; &#125; move(a, b,0); while (queue.size() != 0) &#123; location laca = queue.poll();// System.out.print(&quot;走过(&quot;);// System.out.print(laca.x);// System.out.print(&quot;,&quot;);// System.out.print(laca.y);// System.out.print(&quot;)位置&quot;);// System.out.print(&quot;，步数&quot;);// System.out.println(laca.step); if (laca.x == c &amp;&amp; laca.y == d) &#123; System.out.println(laca.step); queue.clear(); for (int w = 0; w &lt; 9; w++) &#123; Arrays.fill(walked[w], 0);//二维数组全部赋值为0 &#125; break; &#125; else &#123; move(laca.x,laca.y, laca.step); &#125; &#125; &#125; &#125; private static void move(int x, int y, int steps) &#123; //每个点上下左右移动 ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(1); list.add(-1); for (int i : list) &#123; if (x + i &gt; -1 &amp;&amp; x + i &lt;= 8 &amp;&amp; walked[x + i][y] == 0 &amp;&amp; map[x + i][y] == 0) &#123; walked[x + i][y] = 1; location laca = new location(); laca.x = x + i; laca.y = y; laca.step =steps+1; queue.offer(laca); &#125; &#125; for (int i : list) &#123; if (y + i &gt; -1 &amp;&amp; y + i &lt;= 8 &amp;&amp; walked[x][y + i] == 0 &amp;&amp; map[x][y + i] == 0) &#123; walked[x][y + i] = 1; location laca = new location(); laca.x = x; laca.y = y+i; laca.step = steps+1; queue.offer(laca); &#125; &#125; &#125;&#125;class location &#123; int x; int y; int step;&#125; 遇到的问题java结构体java没有结构体，Queue E是泛型 可以自己构建类去充当元素，使用object &#x3D;null去释放赋值对象。 123456789//Interface Queue&lt;E&gt;class location &#123; int x; int y; int step;&#125;location laca = new location();queue.offer(laca); 多维数组赋值为0java.util.Arrays.fill()方法处理的是一维数组，处理二维数组使用： 123for (int w = 0; w &lt; 9; w++) &#123; Arrays.fill(walked[w], 0);//二维数组全部赋值为0&#125; 心得广度优先搜索可以解决最短路径问题，像火一样蔓延，一层层去查找。","categories":[{"name":"OJ","slug":"OJ","permalink":"https://f19t.github.io.git/categories/OJ/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://f19t.github.io.git/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"NYOJ-32-深度优先搜索算法","slug":"NYOJ32-深度优先搜索算法","date":"2023-02-15T03:24:28.000Z","updated":"2023-02-15T07:39:57.412Z","comments":true,"path":"2023/02/15/NYOJ32-深度优先搜索算法/","link":"","permalink":"https://f19t.github.io.git/2023/02/15/NYOJ32-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/","excerpt":"NYOJ-32-深度优先搜索算法最近两天学习了深度优先算法，并做了一道oj题，这里记录一下。","text":"NYOJ-32-深度优先搜索算法最近两天学习了深度优先算法，并做了一道oj题，这里记录一下。 题目描述：描述找出从自然数1、2、… 、n（0&lt;n&lt;10）中任取r(0&lt;r&lt;&#x3D;n)个数的所有组合。 输入描述输入n、r。 输出描述按特定顺序输出所有组合。特定顺序：每一个组合中的值从大到小排列，组合之间按逆字典序排列。 123456789101112输入 5 3输出：543542541532531521432431421321 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.Scanner;public class NYOJ32 &#123; //组合数，深度优先搜索 static Scanner in =new Scanner(System.in); static int n = in.nextInt(); //读取基础数据 static int r = in.nextInt(); //读取长度 static int[] book = new int[n+1];//标记数据是否被使用 static int[] out = new int[r+1]; //设置输出长度 public static void main(String[] args) &#123; dfs(1); &#125; public static void dfs(int step) &#123; int i = 0; if (step &gt; r) &#123; for (i=1;i&lt;=r-1;i++)&#123; //判断高位大于低位 if (out[i]&lt;out[i+1])&#123; return; &#125; &#125; for (i = 1; i &lt;=r; i++) &#123; System.out.print(out[i]); &#125; System.out.println(&quot;&quot;); return; &#125; for (i = n; i &gt; 0; i--) &#123; //深度优先算法 if (book[i] == 0) &#123; out[step]=i; book[i]=1; dfs(step+1); book[i]=0; &#125; &#125; return; &#125;&#125; 学到了，理解深度优先搜索的关键在于解决 “当下该如何做” 。至于 “下一步如何做” 则与 “当下该如何做” 是一样的。","categories":[{"name":"OJ","slug":"OJ","permalink":"https://f19t.github.io.git/categories/OJ/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://f19t.github.io.git/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"NYOJ-2-栈的运用","slug":"NYOJ-2","date":"2023-02-13T11:16:31.000Z","updated":"2023-02-19T12:05:23.308Z","comments":true,"path":"2023/02/13/NYOJ-2/","link":"","permalink":"https://f19t.github.io.git/2023/02/13/NYOJ-2/","excerpt":"NYOJ-2-栈的运用今天刚学java集合，学到了栈，就拿这道题练练手吧。 题目描述12输入描述第一行输入一个数N（0&lt;N&lt;=100）,表示有N组测试数据。后面的N行输入多组输入数据，每组输入数据都是一个字符串S(S的长度小于10000，且S不是空串），测试数据组数少于5组。数据保证S中只含有&quot;[&quot;, “]”, “(”, “)” 四种字符 1每组输入数据的输出占一行，如果该字符串中所含的括号是配对的，则输出Yes,如果不配对则输出No","text":"NYOJ-2-栈的运用今天刚学java集合，学到了栈，就拿这道题练练手吧。 题目描述12输入描述第一行输入一个数N（0&lt;N&lt;=100）,表示有N组测试数据。后面的N行输入多组输入数据，每组输入数据都是一个字符串S(S的长度小于10000，且S不是空串），测试数据组数少于5组。数据保证S中只含有&quot;[&quot;, “]”, “(”, “)” 四种字符 1每组输入数据的输出占一行，如果该字符串中所含的括号是配对的，则输出Yes,如果不配对则输出No 解题思路最近刚学了Deque，可以使用栈解决这个问题。思路：获取到”)”、”]”，就比对，不是就压栈，最后判断是否为空。后续有更好思路再补代码。 1234567891011121314151617181920212223242526272829303132333435363738import java.util.Deque;import java.util.LinkedList;import java.util.Scanner;public class OJ2 &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int num = in.nextInt(); String arr[] = new String[num]; for (int i = 0; i&lt;num;i++)&#123;arr[i]=in.next();&#125; for (int i = 0; i&lt;num;i++)&#123; String s = judge(arr[i]); System.out.println(s); &#125; &#125; public static String judge(String s)&#123; Deque&lt;String&gt; deque = new LinkedList&lt;&gt;(); for (int i =0;i&lt;s.length();i++)&#123; deque.offerLast(s.substring(i,i+1)); if (deque.peekLast().equals(&quot;)&quot;))&#123; if (deque.size()==1)&#123;return &quot;No&quot;;&#125; deque.pollLast(); if (deque.peekLast().equals(&quot;(&quot;))&#123;deque.removeLast();&#125; else &#123;return &quot;No&quot;;&#125; &#125; else if(deque.peekLast().equals(&quot;]&quot;))&#123; if (deque.size()==1)&#123;return &quot;No&quot;;&#125; deque.pollLast(); if (deque.peekLast().equals(&quot;[&quot;))&#123;deque.removeLast();&#125; else &#123;return &quot;No&quot;;&#125; &#125; &#125; if (deque.size()==0)&#123;return &quot;Yes&quot;;&#125;else &#123;return &quot;No&quot;;&#125; &#125;&#125; 学到了比较值需要使用 .equals() 。","categories":[{"name":"OJ","slug":"OJ","permalink":"https://f19t.github.io.git/categories/OJ/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://f19t.github.io.git/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Java集合","slug":"Java集合","date":"2023-02-13T07:38:34.000Z","updated":"2023-02-13T11:26:52.908Z","comments":true,"path":"2023/02/13/Java集合/","link":"","permalink":"https://f19t.github.io.git/2023/02/13/Java%E9%9B%86%E5%90%88/","excerpt":"Java集合本文介绍Java集合的数据结构，与简单测试。为后续学习算法打基础。","text":"Java集合本文介绍Java集合的数据结构，与简单测试。为后续学习算法打基础。 List123456789101112131415import java.util.ArrayList;import java.util.List;public class Test &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;apple&quot;); // size=1 list.add(&quot;pear&quot;); // size=2 list.add(&quot;apple&quot;); // 允许重复添加元素，size=3 System.out.println(list.size()); list.remove(1);//删除pear System.out.println(list.size()); System.out.println(list.get(1)); &#125;&#125; 12332apple List是一种顺序列表接口常用方法： 在末尾添加一个元素：boolean add(E e) 在指定索引添加一个元素：boolean add(int index, E e) 删除指定索引的元素：E remove(int index) 删除某个元素：boolean remove(Object e) 获取指定索引的元素：E get(int index) 获取链表大小（包含元素的个数）：int size() Map1234567891011121314151617import java.util.HashMap;import java.util.Map;public class Test &#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;s&quot;,&quot;bbbbb&quot;); map.put(&quot;a&quot;,&quot;aaaaa&quot;); System.out.println(map.get(&quot;s&quot;));//获取数据 for (String key : map.keySet())&#123; //遍历map System.out.println(map.get(key)); &#125; &#125;&#125; 123bbbbbaaaaabbbbb PropertiesJava默认配置文件以.properties为扩展名，每行以key&#x3D;value表示。java内置Properties读取配置文件非常简单。 典型配置文件： 123# setting.propertieslast_open_file=1.txtauto_save_interval=60 12345678910111213141516171819import java.io.FileNotFoundException;import java.util.Properties;public class Test &#123; public static void main(String[] args) throws FileNotFoundException,Exception&#123; String f = &quot;配置文件&quot;; Properties props = new Properties(); props.load(new java.io.FileInputStream(f)); String filepath = props.getProperty(&quot;last_open_file&quot;); String interval = props.getProperty(&quot;auto_save_interval&quot;, &quot;120&quot;);//如果没有值，赋予默认值 System.out.println(filepath); System.out.println(interval); &#125;&#125; 121.txt60 Set只需要存储不重复的key，并不需要存储映射的value，那么就可以使用Set。 Queue队列（Queue）是一种经常使用的集合。Queue实际上是实现了一个先进先出（FIFO：First In First Out）的有序表。它和List的区别在于，List可以在任意位置添加和删除元素，而Queue只有两个操作： 把元素添加到队列末尾； 从队列头部取出元素。 队列接口Queue定义了以下几个方法： int size()：获取队列长度； boolean add(E)&#x2F;boolean offer(E)：添加元素到队尾； E remove()&#x2F;E poll()：获取队首元素并从队列中删除； E element()&#x2F;E peek()：获取队首元素但并不从队列中删除。 123456789101112131415161718192021222324import java.io.FileNotFoundException;import java.util.*;public class Test &#123; public static void main(String[] args) throws FileNotFoundException,Exception&#123; Queue&lt;String&gt; q = new LinkedList&lt;&gt;(); q.offer(&quot;aaaaaaa&quot;); q.offer(&quot;bbbbbbb&quot;); q.offer(&quot;ccccccc&quot;); System.out.println(q.peek());//获取首位数据，不删除 System.out.println(q.peek()); System.out.println(q.peek()); System.out.println(&quot;-------------&quot;); System.out.println(q.poll());//获取首位数据，并删除 System.out.println(q.poll()); System.out.println(q.poll()); &#125;&#125; 1234567aaaaaaaaaaaaaaaaaaaaa-------------aaaaaaabbbbbbbccccccc Deque两头都出，这种队列叫双端队列（Double Ended Queue），学名Deque。Java集合提供了接口Deque来实现一个双端队列，它的功能是： 既可以添加到队尾，也可以添加到队首； 既可以从队首获取，又可以从队尾获取。 用处：Deque当Stack使用。 123456789101112131415161718192021222324import java.io.FileNotFoundException;import java.util.*;public class Test &#123; public static void main(String[] args) throws FileNotFoundException,Exception&#123; Deque&lt;String&gt; q = new LinkedList&lt;&gt;(); q.offerLast(&quot;aaaaaaa&quot;); q.offerLast(&quot;bbbbbbb&quot;); q.offerLast(&quot;ccccccc&quot;); System.out.println(q.peekLast());//获取末位数据，不删除 System.out.println(q.peekLast()); System.out.println(q.peekLast()); System.out.println(&quot;-------------&quot;); System.out.println(q.pollLast());//获取末位数据，并删除 System.out.println(q.pollLast()); System.out.println(q.pollLast()); &#125;&#125; 1234567ccccccccccccccccccccc-------------cccccccbbbbbbbaaaaaaa","categories":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"https://f19t.github.io.git/categories/JAVA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://f19t.github.io.git/tags/%E7%AE%97%E6%B3%95/"}]}],"categories":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"https://f19t.github.io.git/categories/JAVA%E5%9F%BA%E7%A1%80/"},{"name":"JAVA安全","slug":"JAVA基础/JAVA安全","permalink":"https://f19t.github.io.git/categories/JAVA%E5%9F%BA%E7%A1%80/JAVA%E5%AE%89%E5%85%A8/"},{"name":"OJ","slug":"OJ","permalink":"https://f19t.github.io.git/categories/OJ/"}],"tags":[{"name":"JAVASEC","slug":"JAVASEC","permalink":"https://f19t.github.io.git/tags/JAVASEC/"},{"name":"算法","slug":"算法","permalink":"https://f19t.github.io.git/tags/%E7%AE%97%E6%B3%95/"}]}